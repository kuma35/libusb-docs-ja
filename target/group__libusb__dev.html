<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libusb: デバイスの処理と列挙</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libusb &#160;<span id="projectnumber">1.0.24</span>
   </div>
   <div id="projectbrief">USBデバイスにアクセスするためのクロス・プラットフォームのユーザー・ライブラリ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>


<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license
magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt
GPL-v2 */ $(function() { initMenu('',false,false,'search.php','Search'); });
/* @license-end */</script>
<div id="main-nav"></div>
</div>
<!-- top -->
<div class="header">
  <div class="summary">
<a href="group__libusb__dev.html#typedef-members">Typedefs</a> &#124; <a
href="group__libusb__dev.html#enum-members">列挙</a> &#124; <a
href="group__libusb__dev.html#func-members">関数</a>  </div>
  <div class="headertitle">
<div class="title">デバイスの処理と列挙</div>  </div>
</div>
<!--header-->
<div class="contents">

<p>以下の各機能は、各行に記述の操作を支援するように設計されています: <a
href="group__libusb__dev.html#details">さらに…</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a> Typedef</h2></td></tr>
<tr class="memitem:ga77eedd00d01eb7569b880e861a971c2b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a></td></tr>
<tr class="separator:ga77eedd00d01eb7569b880e861a971c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df95821d20d27b5597f1d783749d6a4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a></td></tr>
<tr class="separator:ga7df95821d20d27b5597f1d783749d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a> Enum</h2></td></tr>
<tr class="memitem:ga2959abf1184f87b2ce06fe90db6ce614"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga2959abf1184f87b2ce06fe90db6ce614">libusb_speed</a>
{ <br />
&#160;&#160;<a class="el"
href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614ace31df1e97e9a66146ac83dcab1e6cfb">LIBUSB_SPEED_UNKNOWN</a>
= 0, <a class="el"
href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614a6017f9ac2509cd523b51c1b72ad6991b">LIBUSB_SPEED_LOW</a>
= 1, <a class="el"
href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614a0011bead7a48b873808795d8495b4d9e">LIBUSB_SPEED_FULL</a>
= 2, <a class="el"
href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614a27bc0b9fe76f8ddf524f3d2ece0eefac">LIBUSB_SPEED_HIGH</a>
= 3, 
<br />
&#160;&#160;<a class="el"
href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614ab8c71e1409cd555ae05937b4db9946a2">LIBUSB_SPEED_SUPER</a>
= 4, <a class="el"
href="group__libusb__dev.html#gga2959abf1184f87b2ce06fe90db6ce614aa65f23e14e68162a142f26dac5fcfc4a">LIBUSB_SPEED_SUPER_PLUS</a>
= 5
<br />
 }</td></tr>
<tr class="separator:ga2959abf1184f87b2ce06fe90db6ce614"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a> 関数群</h2></td></tr>
<tr class="memitem:gac0fe4b65914c5ed036e6cbec61cb0b97"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, <a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
***list)</td></tr>
<tr class="separator:gac0fe4b65914c5ed036e6cbec61cb0b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b8561d064bb3e1b8851ddeed3cd7d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
**list, int unref_devices)</td></tr>
<tr class="separator:gad3b8561d064bb3e1b8851ddeed3cd7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2718609d50c8ded2704e4051b3d2925"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gaf2718609d50c8ded2704e4051b3d2925">libusb_get_bus_number</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev)</td></tr>
<tr class="separator:gaf2718609d50c8ded2704e4051b3d2925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14879a0ea7daccdcddb68852d86c00c4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga14879a0ea7daccdcddb68852d86c00c4">libusb_get_port_number</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev)</td></tr>
<tr class="separator:ga14879a0ea7daccdcddb68852d86c00c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b7b2b50a9ce2aa396b0af2b979544d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gaa4b7b2b50a9ce2aa396b0af2b979544d">libusb_get_port_numbers</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev, uint8_t *port_numbers, int port_numbers_len)</td></tr>
<tr class="separator:gaa4b7b2b50a9ce2aa396b0af2b979544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d392b8dff7abf5e475c72fd071c3c34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga9d392b8dff7abf5e475c72fd071c3c34">libusb_get_port_path</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, <a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev, uint8_t *port_numbers, uint8_t port_numbers_len)</td></tr>
<tr class="separator:ga9d392b8dff7abf5e475c72fd071c3c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97bb4dfff6bbb897ed9dfd6fa1a1deed"><td class="memItemLeft" align="right" valign="top"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga97bb4dfff6bbb897ed9dfd6fa1a1deed">libusb_get_parent</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev)</td></tr>
<tr class="separator:ga97bb4dfff6bbb897ed9dfd6fa1a1deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d4e39ac483ebaeb108f2954715305d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gab6d4e39ac483ebaeb108f2954715305d">libusb_get_device_address</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev)</td></tr>
<tr class="separator:gab6d4e39ac483ebaeb108f2954715305d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58c4e448ecd5cd4782f2b896ec40b22b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga58c4e448ecd5cd4782f2b896ec40b22b">libusb_get_device_speed</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev)</td></tr>
<tr class="separator:ga58c4e448ecd5cd4782f2b896ec40b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81968047e262409e78f3fe24321b604"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gac81968047e262409e78f3fe24321b604">libusb_get_max_packet_size</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev, unsigned char endpoint)</td></tr>
<tr class="separator:gac81968047e262409e78f3fe24321b604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec10b71c7209760db55ee0f8768bb4f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gaec10b71c7209760db55ee0f8768bb4f0">libusb_get_max_iso_packet_size</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev, unsigned char endpoint)</td></tr>
<tr class="separator:gaec10b71c7209760db55ee0f8768bb4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabaa4193adcabba1789cc1165ac41a03"><td class="memItemLeft" align="right" valign="top"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gaabaa4193adcabba1789cc1165ac41a03">libusb_ref_device</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev)</td></tr>
<tr class="separator:gaabaa4193adcabba1789cc1165ac41a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc62e6a191b7a9f213e62b81ec30f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga3cc62e6a191b7a9f213e62b81ec30f4d">libusb_unref_device</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev)</td></tr>
<tr class="separator:ga3cc62e6a191b7a9f213e62b81ec30f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f783e115ceff4eaf88a60e6439563c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga98f783e115ceff4eaf88a60e6439563c">libusb_wrap_sys_device</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, intptr_t sys_dev, <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
**dev_handle)</td></tr>
<tr class="separator:ga98f783e115ceff4eaf88a60e6439563c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f184a8be4488a767b2e0ae07e76d1b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open</a>
(<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*dev, <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
**dev_handle)</td></tr>
<tr class="separator:ga3f184a8be4488a767b2e0ae07e76d1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ba48adb896b1492bbd3d0bf7e0f665"><td class="memItemLeft" align="right" valign="top"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga11ba48adb896b1492bbd3d0bf7e0f665">libusb_open_device_with_vid_pid</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, uint16_t vendor_id, uint16_t product_id)</td></tr>
<tr class="separator:ga11ba48adb896b1492bbd3d0bf7e0f665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779bc4f1316bdb0ac383bddbd538620e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle)</td></tr>
<tr class="separator:ga779bc4f1316bdb0ac383bddbd538620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe70b8a797893d4d16985980acec956a"><td class="memItemLeft" align="right" valign="top"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gafe70b8a797893d4d16985980acec956a">libusb_get_device</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle)</td></tr>
<tr class="separator:gafe70b8a797893d4d16985980acec956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae921014b888b105471a31d54c77c1c4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">libusb_get_configuration</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int *config)</td></tr>
<tr class="separator:gae921014b888b105471a31d54c77c1c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785ddea63a2b9bcb879a614ca4867bed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int configuration)</td></tr>
<tr class="separator:ga785ddea63a2b9bcb879a614ca4867bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5076addf5de77c7962138397fd5b1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a">libusb_claim_interface</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int interface_number)</td></tr>
<tr class="separator:gaee5076addf5de77c7962138397fd5b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b5cb0d894f6807cd1693ef29aecbfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa">libusb_release_interface</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int interface_number)</td></tr>
<tr class="separator:ga49b5cb0d894f6807cd1693ef29aecbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4858ad4f0f58fd1dc0afaead1fe6479a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga4858ad4f0f58fd1dc0afaead1fe6479a">libusb_set_interface_alt_setting</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int interface_number, int alternate_setting)</td></tr>
<tr class="separator:ga4858ad4f0f58fd1dc0afaead1fe6479a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab794bbc0b055d140f186f5a4d39c0891"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gab794bbc0b055d140f186f5a4d39c0891">libusb_clear_halt</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, unsigned char endpoint)</td></tr>
<tr class="separator:gab794bbc0b055d140f186f5a4d39c0891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee9c4638f1713ca5faa867948878111"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gafee9c4638f1713ca5faa867948878111">libusb_reset_device</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle)</td></tr>
<tr class="separator:gafee9c4638f1713ca5faa867948878111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cabd4660a274f715eeb82de112e0779"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga1cabd4660a274f715eeb82de112e0779">libusb_kernel_driver_active</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int interface_number)</td></tr>
<tr class="separator:ga1cabd4660a274f715eeb82de112e0779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0cc1d666097e915748593effdc634a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#ga5e0cc1d666097e915748593effdc634a">libusb_detach_kernel_driver</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int interface_number)</td></tr>
<tr class="separator:ga5e0cc1d666097e915748593effdc634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeba36e900db663c0b7cf1b164a20d02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gadeba36e900db663c0b7cf1b164a20d02">libusb_attach_kernel_driver</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int interface_number)</td></tr>
<tr class="separator:gadeba36e900db663c0b7cf1b164a20d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35b26fef01271eba65c60b2b3ce1cbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf">libusb_set_auto_detach_kernel_driver</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, int enable)</td></tr>
<tr class="separator:gac35b26fef01271eba65c60b2b3ce1cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳細説明</h2>
<p>以下に記載されている各機能は、各業に記述の操作を支援するように設計されています: </p>
<ul>
<li>現在システムに接続されているUSBデバイスを列挙する</li>
<li>あなたのソフトウェアから操作するデバイスの選択</li>
<li>選択したデバイスのオープンとクローズ</li>
</ul>
<h1><a class="anchor" id="nutshell"></a> 一言で言えば…</h1>
<p>以下の説明は、実際よりも複雑に聞こえます。
次の一連の関数呼び出しは、ほとんどすべてのシナリオに適しており、リソース管理の問題を深く理解している必要はありません: </p><div class="fragment"><div class="line"><span class="comment">// discover devices</span></div>
<div class="line"><a class="code"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
**list;</div>
<div class="line"><a class="code"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*found = NULL;</div>
<div class="line">ssize_t cnt = <a class="code"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list</a>(NULL,
&amp;list);</div>
<div class="line">ssize_t i = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line"><span class="keywordflow">if</span> (cnt &lt; 0)</div>
<div class="line">    error();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; cnt; i++) {</div>
<div class="line">    <a class="code"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*device = list[i];</div>
<div class="line">    <span class="keywordflow">if</span> (is_interesting(device)) {</div>
<div class="line">        found = device;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (found) {</div>
<div class="line">    <a class="code"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*handle;</div>
<div class="line"> </div>
<div class="line">    err = <a class="code"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open</a>(found,
&amp;handle);</div>
<div class="line">    <span class="keywordflow">if</span> (err)</div>
<div class="line">        error();</div>
<div class="line">    <span class="comment">// etc</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list</a>(list,
1);</div>
</div><!-- fragment -->
<p>2つの重要な点:</p><ul>
<li>あなたは <a class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>
にデバイスの参照を解除するように依頼しました(2番目のパラメーター)</li>
<li>リストを解放してデバイスの参照を解除する前に、あなたはデバイスをオープンした</li>
</ul>
<p>ハンドルを使い終わったら、デバイスでの入出力に進むことができます。</p>
<h1><a class="anchor" id="devshandles"></a> デバイスとデバイス・ハンドル</h1>
<p>libusbには、<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>不透明(opaque)型で表されるUSBデバイスの概念があります。デバイスは、現在または以前にシステムに接続されていたUSBデバイスを表します。デバイスへの参照を使用して、デバイスに関する特定の情報を判別できます(たとえば、デスクリプター・データを読み取ることができます)。</p>
<p><a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>関数を使用して、現在システムに接続されているデバイスのリストを取得できます。これは、デバイス検出として知られています。</p>
<p>デバイスへの参照があるからといって、それが必ずしも使用可能であるとは限りません。デバイスのプラグが抜かれているか、そのようなデバイスを操作する権限がないか、別のプログラムまたはドライバーがデバイスを使用している可能性があります。</p>
<p>操作したいデバイスを見つけたら、<a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>関数を使用してデバイスをオープンするようlibusbに依頼する必要があります。成功すると、libusbは<em>デバイス・ハンドル</em>(<a
class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>ポインタ)を返します。すべての
"実際の" 入出力操作は、元のデバイス・ポインタではなくそのハンドルで操作します。</p>
<h1><a class="anchor" id="devref"></a>デバイス検出とリファレンス・カウント</h1>
<p>デバイスの検出(つまり、<a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()の呼び出し)は、新しく割り当てられたデバイスのリストを返します。リストを使い終わったらリスト自体を解放する必要があります。libusbはリストの内容(デバイス自体)を解放してもよいかを知る必要もあります。</p>
<p>これらの問題を処理するために、libusbは2つの別個のアイテムを提供します:</p><ul>
<li>リスト自体を解放する関数</li>
<li>内部のデバイスの参照カウンター・システム</li>
</ul>
<p><a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>関数によって提示される新しいデバイスの参照カウンターはすべて1です。<a
class="el"
href="group__libusb__dev.html#gaabaa4193adcabba1789cc1165ac41a03">libusb_ref_device()</a>
と <a class="el"
href="group__libusb__dev.html#ga3cc62e6a191b7a9f213e62b81ec30f4d">libusb_unref_device()</a>
を使用して参照カウンターを増減できます。参照カウンターが0に達すると、デバイスは破棄されます。</p>
<p>上記の情報を念頭に置くと、デバイスをオープンする手順は以下のようになります:</p><ol type="1">
<li><a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>
を使ってデバイスを検出します。</li>
<li>あなたが操作したいデバイスを選び、<a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
を呼びます。</li>
<li>検出されたデバイス・リスト内のすべてのデバイスへの参照を解除(unref)します。</li>
<li>検出されたデバイス・リストを解放します。</li>
</ol>
<p>この順番は重要です。参照解除(unreference)はデバイスを破壊する可能性があるため、オープンする前にデバイスへの参照を解除(unreference)しないでください。</p>
<p>便宜上、<a class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>
関数には、リスト自体を解放する前に、オプションでリスト内のすべてのデバイスを参照解除(unreference)するパラメーターが含まれています。これは、上記のステップ3と4を組み合わせたものです。</p>
<p>実装の詳細として、<a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>は実際に問題のデバイスへの参照を追加します。
これは、デバイスが<a class="el"
href="group__libusb__dev.html#gafe70b8a797893d4d16985980acec956a">libusb_get_device()</a>を介してハンドルから引き続き利用できるためです。参照は、<a
class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>の処理中に削除されます。 </p>
<h2 class="groupheader">Typedef 文書</h2>
<a id="ga77eedd00d01eb7569b880e861a971c2b"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">&#9670;&nbsp;</a></span>libusb_device</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
<a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>システムで検出されたUSBデバイスを表す構造(structure)。 これは不透明(opaque)型であり、通常は <a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>
からポインタが提供されます。</p>
<p>特定の操作はデバイスで実行できますが、入出力を実行するには、最初に <a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
を使用してデバイス・ハンドルを取得する必要があります。</p>
<p>デバイスは、<a class="el"
href="group__libusb__dev.html#gaabaa4193adcabba1789cc1165ac41a03">libusb_ref_device()</a>
と <a class="el"
href="group__libusb__dev.html#ga3cc62e6a191b7a9f213e62b81ec30f4d">libusb_unref_device()</a>
により参照カウンターを増減し、参照カウンターが0に達すると解放されます。<a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>
によって提示される新しいデバイスの参照カウンターは1で、 <a class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>
はオプションでリスト内のすべてのデバイスの参照カウンターを減らすことができます。 <a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
は、後で <a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>
によって破棄される別の参照を追加します。 </p>

</div>
</div>
<a id="ga7df95821d20d27b5597f1d783749d6a4"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">&#9670;&nbsp;</a></span>libusb_device_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Structure representing a handle on a USB device. This is an opaque type for
which you are only ever provided with a pointer, usually originating from <a
class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>.</p>
<p>A device handle is used to perform I/O and other operations. When finished
with a device handle, you should call <a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2959abf1184f87b2ce06fe90db6ce614"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga2959abf1184f87b2ce06fe90db6ce614">&#9670;&nbsp;</a></span>libusb_speed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el"
href="group__libusb__dev.html#ga2959abf1184f87b2ce06fe90db6ce614">libusb_speed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Speed codes. Indicates the speed at which the device is operating. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a
id="gga2959abf1184f87b2ce06fe90db6ce614ace31df1e97e9a66146ac83dcab1e6cfb"></a>LIBUSB_SPEED_UNKNOWN&#160;</td><td class="fielddoc"><p>The OS doesn't report or know the device speed. </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga2959abf1184f87b2ce06fe90db6ce614a6017f9ac2509cd523b51c1b72ad6991b"></a>LIBUSB_SPEED_LOW&#160;</td><td class="fielddoc"><p>The device is operating at low speed (1.5MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga2959abf1184f87b2ce06fe90db6ce614a0011bead7a48b873808795d8495b4d9e"></a>LIBUSB_SPEED_FULL&#160;</td><td class="fielddoc"><p>The device is operating at full speed (12MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga2959abf1184f87b2ce06fe90db6ce614a27bc0b9fe76f8ddf524f3d2ece0eefac"></a>LIBUSB_SPEED_HIGH&#160;</td><td class="fielddoc"><p>The device is operating at high speed (480MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga2959abf1184f87b2ce06fe90db6ce614ab8c71e1409cd555ae05937b4db9946a2"></a>LIBUSB_SPEED_SUPER&#160;</td><td class="fielddoc"><p>The device is operating at super speed (5000MBit/s). </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga2959abf1184f87b2ce06fe90db6ce614aa65f23e14e68162a142f26dac5fcfc4a"></a>LIBUSB_SPEED_SUPER_PLUS&#160;</td><td class="fielddoc"><p>The device is operating at super speed plus (10000MBit/s). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac0fe4b65914c5ed036e6cbec61cb0b97"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">&#9670;&nbsp;</a></span>libusb_get_device_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t libusb_get_device_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
***&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of USB devices currently attached to the system. This is your
entry point into finding a USB device to operate.</p>
<p>You are expected to unreference all the devices when you are done with them,
and then free the list with <a class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>.
Note that <a class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>
can unref all the devices for you. Be careful not to unreference a device
you are about to open until after you have opened it.</p>
<p>This return value of this function indicates the number of devices in the
resultant list. The list is actually one element larger, as it is
NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to operate on, or NULL for the default context </td></tr>
    <tr><td class="paramname">list</td><td>output location for a list of devices. Must be later freed with <a
class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of devices in the outputted list, or any <a class="el"
href="group__libusb__misc.html#gab2323aa0f04bc22038e7e1740b2f29ef">libusb_error</a>
according to errors encountered by the backend. </dd></dl>

</div>
</div>
<a id="gad3b8561d064bb3e1b8851ddeed3cd7d6"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">&#9670;&nbsp;</a></span>libusb_free_device_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_free_device_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
**&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unref_devices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a list of devices previously discovered using <a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>.
If the unref_devices parameter is set, the reference count of each device in
the list is decremented by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list to free </td></tr>
    <tr><td class="paramname">unref_devices</td><td>whether to unref the devices in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2718609d50c8ded2704e4051b3d2925"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gaf2718609d50c8ded2704e4051b3d2925">&#9670;&nbsp;</a></span>libusb_get_bus_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t libusb_get_bus_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of the bus that a device is connected to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bus number </dd></dl>

</div>
</div>
<a id="ga14879a0ea7daccdcddb68852d86c00c4"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga14879a0ea7daccdcddb68852d86c00c4">&#9670;&nbsp;</a></span>libusb_get_port_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t libusb_get_port_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of the port that a device is connected to. Unless the OS does
something funky, or you are hot-plugging USB extension cards, the port
number returned by this call is usually guaranteed to be uniquely tied to a
physical port, meaning that different devices plugged on the same physical
port should return the same port number.</p>
<p>But outside of this, there is no guarantee that the port number returned by
this call will remain the same, or even match the order in which ports have
been numbered by the HUB/HCD manufacturer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the port number (0 if not available) </dd></dl>

</div>
</div>
<a id="gaa4b7b2b50a9ce2aa396b0af2b979544d"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gaa4b7b2b50a9ce2aa396b0af2b979544d">&#9670;&nbsp;</a></span>libusb_get_port_numbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_port_numbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>port_numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_numbers_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the list of all port numbers from root for the specified device</p>
<p>Since version 1.0.16, <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000102 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
    <tr><td class="paramname">port_numbers</td><td>the array that should contain the port numbers </td></tr>
    <tr><td class="paramname">port_numbers_len</td><td>the maximum length of the array. As per the USB 3.0 specs, the current
maximum limit for the depth is 7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements filled </dd>
<dd>
LIBUSB_ERROR_OVERFLOW if the array is too small </dd></dl>

</div>
</div>
<a id="ga9d392b8dff7abf5e475c72fd071c3c34"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga9d392b8dff7abf5e475c72fd071c3c34">&#9670;&nbsp;</a></span>libusb_get_port_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_port_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>port_numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_numbers_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el"
href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Please use <a class="el"
href="group__libusb__dev.html#gaa4b7b2b50a9ce2aa396b0af2b979544d">libusb_get_port_numbers()</a>
instead. </dd></dl>

</div>
</div>
<a id="ga97bb4dfff6bbb897ed9dfd6fa1a1deed"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga97bb4dfff6bbb897ed9dfd6fa1a1deed">&#9670;&nbsp;</a></span>libusb_get_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>*
libusb_get_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the the parent from the specified device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device parent or NULL if not available You should issue a <a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>
before calling this function and make sure that you only access the parent
before issuing <a class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>.
The reason is that libusb currently does not maintain a permanent list of
device instances, and therefore can only guarantee that parents are fully
instantiated within a <a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>
- <a class="el"
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list()</a>
block. </dd></dl>

</div>
</div>
<a id="gab6d4e39ac483ebaeb108f2954715305d"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gab6d4e39ac483ebaeb108f2954715305d">&#9670;&nbsp;</a></span>libusb_get_device_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t libusb_get_device_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the address of the device on the bus it is connected to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device address </dd></dl>

</div>
</div>
<a id="ga58c4e448ecd5cd4782f2b896ec40b22b"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga58c4e448ecd5cd4782f2b896ec40b22b">&#9670;&nbsp;</a></span>libusb_get_device_speed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_device_speed </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the negotiated connection speed for a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el"
href="group__libusb__dev.html#ga2959abf1184f87b2ce06fe90db6ce614">libusb_speed</a>
code, where LIBUSB_SPEED_UNKNOWN means that the OS doesn't know or doesn't
support returning the negotiated speed. </dd></dl>

</div>
</div>
<a id="gac81968047e262409e78f3fe24321b604"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gac81968047e262409e78f3fe24321b604">&#9670;&nbsp;</a></span>libusb_get_max_packet_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_max_packet_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function to retrieve the wMaxPacketSize value for a particular
endpoint in the active device configuration.</p>
<p>This function was originally intended to be of assistance when setting up
isochronous transfers, but a design mistake resulted in this function
instead. It simply returns the wMaxPacketSize value without considering its
contents. If you're dealing with isochronous transfers, you probably want <a
class="el"
href="group__libusb__dev.html#gaec10b71c7209760db55ee0f8768bb4f0">libusb_get_max_iso_packet_size()</a>
instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
    <tr><td class="paramname">endpoint</td><td>address of the endpoint in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the wMaxPacketSize value </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </dd>
<dd>
LIBUSB_ERROR_OTHER on other failure </dd></dl>

</div>
</div>
<a id="gaec10b71c7209760db55ee0f8768bb4f0"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gaec10b71c7209760db55ee0f8768bb4f0">&#9670;&nbsp;</a></span>libusb_get_max_iso_packet_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_max_iso_packet_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the maximum packet size which a specific endpoint is capable is
sending or receiving in the duration of 1 microframe</p>
<p>Only the active configuration is examined. The calculation is based on the
wMaxPacketSize field in the endpoint descriptor as described in section
9.6.6 in the USB 2.0 specifications.</p>
<p>If acting on an isochronous or interrupt endpoint, this function will
multiply the value found in bits 0:10 by the number of transactions per
microframe (determined by bits 11:12). Otherwise, this function just returns
the numeric value found in bits 0:10. For USB 3.0 device, it will attempts
to retrieve the Endpoint Companion Descriptor to return wBytesPerInterval.</p>
<p>This function is useful for setting up isochronous transfers, for example
you might pass the return value from this function to <a class="el"
href="group__libusb__asyncio.html#gacbdecd6f50093f0c1d0e72ee35ace274">libusb_set_iso_packet_lengths()</a>
in order to set the length field of every isochronous packet in a transfer.</p>
<p>Since v1.0.3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
    <tr><td class="paramname">endpoint</td><td>address of the endpoint in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum packet size which can be sent/received on this endpoint </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </dd>
<dd>
LIBUSB_ERROR_OTHER on other failure </dd></dl>

</div>
</div>
<a id="gaabaa4193adcabba1789cc1165ac41a03"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gaabaa4193adcabba1789cc1165ac41a03">&#9670;&nbsp;</a></span>libusb_ref_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>*
libusb_ref_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increment the reference count of a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the same device </dd></dl>

</div>
</div>
<a id="ga3cc62e6a191b7a9f213e62b81ec30f4d"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga3cc62e6a191b7a9f213e62b81ec30f4d">&#9670;&nbsp;</a></span>libusb_unref_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_unref_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrement the reference count of a device. If the decrement operation causes
the reference count to reach zero, the device shall be destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to unreference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98f783e115ceff4eaf88a60e6439563c"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga98f783e115ceff4eaf88a60e6439563c">&#9670;&nbsp;</a></span>libusb_wrap_sys_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_wrap_sys_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>sys_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
**&#160;</td>
          <td class="paramname"><em>dev_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap a platform-specific system device handle and obtain a libusb device
handle for the underlying device. The handle allows you to use libusb to
perform I/O on the device in question.</p>
<p>Must call libusb_set_option(NULL, LIBUSB_OPTION_WEAK_AUTHORITY) before
libusb_init if don't have authority to access the usb device directly.</p>
<p>On Linux, the system device handle must be a valid file descriptor opened on
the device node.</p>
<p>The system device handle must remain open until <a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>
is called. The system device handle will not be closed by <a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>.</p>
<p>Internally, this function creates a temporary device and makes it available
to you through <a class="el"
href="group__libusb__dev.html#gafe70b8a797893d4d16985980acec956a">libusb_get_device()</a>.
This device is destroyed during <a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>.
The device shall not be opened through <a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>.</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to operate on, or NULL for the default context </td></tr>
    <tr><td class="paramname">sys_dev</td><td>the platform-specific system device handle </td></tr>
    <tr><td class="paramname">dev_handle</td><td>output location for the returned device handle pointer. Only populated when
the return code is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NO_MEM on memory allocation failure </dd>
<dd>
LIBUSB_ERROR_ACCESS if the user has insufficient permissions </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED if the operation is not supported on this
platform </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a id="ga3f184a8be4488a767b2e0ae07e76d1b0"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">&#9670;&nbsp;</a></span>libusb_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
*&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
**&#160;</td>
          <td class="paramname"><em>dev_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a device and obtain a device handle. A handle allows you to perform I/O
on the device in question.</p>
<p>Internally, this function adds a reference to the device and makes it
available to you through <a class="el"
href="group__libusb__dev.html#gafe70b8a797893d4d16985980acec956a">libusb_get_device()</a>.
This reference is removed during <a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>.</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to open </td></tr>
    <tr><td class="paramname">dev_handle</td><td>output location for the returned device handle pointer. Only populated when
the return code is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NO_MEM on memory allocation failure </dd>
<dd>
LIBUSB_ERROR_ACCESS if the user has insufficient permissions </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a id="ga11ba48adb896b1492bbd3d0bf7e0f665"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga11ba48adb896b1492bbd3d0bf7e0f665">&#9670;&nbsp;</a></span>libusb_open_device_with_vid_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>*
libusb_open_device_with_vid_pid </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vendor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>product_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function for finding a device with a particular
<code>idVendor</code>/<code>idProduct</code> combination. This function is
intended for those scenarios where you are using libusb to knock up a quick
test application - it allows you to avoid calling <a class="el"
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list()</a>
and worrying about traversing/freeing the list.</p>
<p>This function has limitations and is hence not intended for use in real
applications: if multiple devices have the same IDs it will only give you
the first one, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to operate on, or NULL for the default context </td></tr>
    <tr><td class="paramname">vendor_id</td><td>the idVendor value to search for </td></tr>
    <tr><td class="paramname">product_id</td><td>the idProduct value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a device handle for the first found device, or NULL on error or if the
device could not be found. </dd></dl>

</div>
</div>
<a id="ga779bc4f1316bdb0ac383bddbd538620e"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">&#9670;&nbsp;</a></span>libusb_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a device handle. Should be called on all open handles before your
application exits.</p>
<p>Internally, this function destroys the reference that was added by <a
class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
on the given device.</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>the device handle to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe70b8a797893d4d16985980acec956a"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gafe70b8a797893d4d16985980acec956a">&#9670;&nbsp;</a></span>libusb_get_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el"
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>*
libusb_get_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the underlying device for a device handle. This function does not modify
the reference count of the returned device, so do not feel compelled to
unreference it when you are done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying device </dd></dl>

</div>
</div>
<a id="gae921014b888b105471a31d54c77c1c4d"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">&#9670;&nbsp;</a></span>libusb_get_configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the bConfigurationValue of the currently active configuration.</p>
<p>You could formulate your own control request to obtain this information, but
this function has the advantage that it may be able to retrieve the
information from operating system caches (no I/O involved).</p>
<p>If the OS does not cache this information, then this function will block
while a control transfer is submitted to retrieve the information.</p>
<p>This function will return a value of 0 in the <code>config</code> output
parameter if the device is in unconfigured state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">config</td><td>output location for the bConfigurationValue of the active configuration
(only valid for return code 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a id="ga785ddea63a2b9bcb879a614ca4867bed"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">&#9670;&nbsp;</a></span>libusb_set_configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_set_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the active configuration for a device.</p>
<p>The operating system may or may not have already set an active configuration
on the device. It is up to your application to ensure the correct
configuration is selected before you attempt to claim interfaces and perform
other operations.</p>
<p>If you call this function on a device already configured with the selected
configuration, then this function will act as a lightweight device reset: it
will issue a SET_CONFIGURATION request using the current configuration,
causing most USB-related device state to be reset (altsetting reset to zero,
endpoint halts cleared, toggles reset).</p>
<p>Not all backends support setting the configuration from user space, which
will be indicated by the return code LIBUSB_ERROR_NOT_SUPPORTED. As this
suggests that the platform is handling the device configuration itself, this
error should generally be safe to ignore.</p>
<p>You cannot change/reset configuration if your application has claimed
interfaces. It is advised to set the desired configuration before claiming
interfaces.</p>
<p>Alternatively you can call <a class="el"
href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa">libusb_release_interface()</a>
first. Note if you do things this way you must ensure that
auto_detach_kernel_driver for <code>dev</code> is 0, otherwise the kernel
driver will be re-attached when you release the interface(s).</p>
<p>You cannot change/reset configuration if other applications or drivers have
claimed interfaces.</p>
<p>A configuration value of -1 will put the device in unconfigured state. The
USB specifications state that a configuration value of 0 does this, however
buggy devices exist which actually have a configuration 0.</p>
<p>You should always use this function rather than formulating your own
SET_CONFIGURATION control request. This is because the underlying operating
system needs to know when such changes happen.</p>
<p>This is a blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">configuration</td><td>the bConfigurationValue of the configuration you wish to activate, or -1 if
you wish to put the device in an unconfigured state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the requested configuration does not exist </dd>
<dd>
LIBUSB_ERROR_BUSY if interfaces are currently claimed </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED if setting or changing the configuration is not
supported by the backend </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el"
href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf">libusb_set_auto_detach_kernel_driver()</a> </dd></dl>

</div>
</div>
<a id="gaee5076addf5de77c7962138397fd5b1a"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a">&#9670;&nbsp;</a></span>libusb_claim_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_claim_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Claim an interface on a given device handle. You must claim the interface
you wish to use before you can perform I/O on any of its endpoints.</p>
<p>It is legal to attempt to claim an already-claimed interface, in which case
libusb just returns 0 without doing anything.</p>
<p>If auto_detach_kernel_driver is set to 1 for <code>dev</code>, the kernel
driver will be detached if necessary, on failure the detach error is
returned.</p>
<p>Claiming of interfaces is a purely logical operation; it does not cause any
requests to be sent over the bus. Interface claiming is used to instruct the
underlying operating system that your application wishes to take ownership
of the interface.</p>
<p>This is a non-blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the <code>bInterfaceNumber</code> of the interface you wish to claim </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the requested interface does not exist </dd>
<dd>
LIBUSB_ERROR_BUSY if another program or driver has claimed the interface </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
a LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el"
href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf">libusb_set_auto_detach_kernel_driver()</a> </dd></dl>

</div>
</div>
<a id="ga49b5cb0d894f6807cd1693ef29aecbfa"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa">&#9670;&nbsp;</a></span>libusb_release_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_release_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release an interface previously claimed with <a class="el"
href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a">libusb_claim_interface()</a>.
You should release all claimed interfaces before closing a device handle.</p>
<p>This is a blocking function. A SET_INTERFACE control request will be sent to
the device, resetting interface state to the first alternate setting.</p>
<p>If auto_detach_kernel_driver is set to 1 for <code>dev</code>, the kernel
driver will be re-attached after releasing the interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the <code>bInterfaceNumber</code> of the previously-claimed interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the interface was not claimed </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el"
href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf">libusb_set_auto_detach_kernel_driver()</a> </dd></dl>

</div>
</div>
<a id="ga4858ad4f0f58fd1dc0afaead1fe6479a"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga4858ad4f0f58fd1dc0afaead1fe6479a">&#9670;&nbsp;</a></span>libusb_set_interface_alt_setting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_set_interface_alt_setting </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alternate_setting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activate an alternate setting for an interface. The interface must have been
previously claimed with <a class="el"
href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a">libusb_claim_interface()</a>.</p>
<p>You should always use this function rather than formulating your own
SET_INTERFACE control request. This is because the underlying operating
system needs to know when such changes happen.</p>
<p>This is a blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the <code>bInterfaceNumber</code> of the previously-claimed interface </td></tr>
    <tr><td class="paramname">alternate_setting</td><td>the <code>bAlternateSetting</code> of the alternate setting to activate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the interface was not claimed, or the requested
alternate setting does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a id="gab794bbc0b055d140f186f5a4d39c0891"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gab794bbc0b055d140f186f5a4d39c0891">&#9670;&nbsp;</a></span>libusb_clear_halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_clear_halt </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the halt/stall condition for an endpoint. Endpoints with halt status
are unable to receive or transmit data until the halt condition is stalled.</p>
<p>You should cancel all pending transfers before attempting to clear the halt
condition.</p>
<p>This is a blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">endpoint</td><td>the endpoint to clear halt status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a id="gafee9c4638f1713ca5faa867948878111"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gafee9c4638f1713ca5faa867948878111">&#9670;&nbsp;</a></span>libusb_reset_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_reset_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a USB port reset to reinitialize a device. The system will attempt
to restore the previous configuration and alternate settings after the reset
has completed.</p>
<p>If the reset fails, the descriptors change, or the previous state cannot be
restored, the device will appear to be disconnected and reconnected. This
means that the device handle is no longer valid (you should close it) and
rediscover the device. A return code of LIBUSB_ERROR_NOT_FOUND indicates
when this is the case.</p>
<p>This is a blocking function which usually incurs a noticeable delay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a handle of the device to reset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if re-enumeration is required, or if the device has
been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a id="ga1cabd4660a274f715eeb82de112e0779"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga1cabd4660a274f715eeb82de112e0779">&#9670;&nbsp;</a></span>libusb_kernel_driver_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_kernel_driver_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a kernel driver is active on an interface. If a kernel driver
is active, you cannot claim the interface, and libusb will be unable to
perform I/O.</p>
<p>This functionality is not available on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no kernel driver is active </dd>
<dd>
1 if a kernel driver is active </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not
available </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el"
href="group__libusb__dev.html#ga5e0cc1d666097e915748593effdc634a">libusb_detach_kernel_driver()</a> </dd></dl>

</div>
</div>
<a id="ga5e0cc1d666097e915748593effdc634a"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#ga5e0cc1d666097e915748593effdc634a">&#9670;&nbsp;</a></span>libusb_detach_kernel_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_detach_kernel_driver </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach a kernel driver from an interface. If successful, you will then be
able to claim the interface and perform I/O.</p>
<p>This functionality is not available on Darwin or Windows.</p>
<p>Note that libusb itself also talks to the device through a special kernel
driver, if this driver is already attached to the device, this call will not
detach it and return LIBUSB_ERROR_NOT_FOUND.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to detach the driver from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if no kernel driver was active </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM if the interface does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not
available </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el"
href="group__libusb__dev.html#ga1cabd4660a274f715eeb82de112e0779">libusb_kernel_driver_active()</a> </dd></dl>

</div>
</div>
<a id="gadeba36e900db663c0b7cf1b164a20d02"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gadeba36e900db663c0b7cf1b164a20d02">&#9670;&nbsp;</a></span>libusb_attach_kernel_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_attach_kernel_driver </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interface_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Re-attach an interface's kernel driver, which was previously detached using
<a class="el"
href="group__libusb__dev.html#ga5e0cc1d666097e915748593effdc634a">libusb_detach_kernel_driver()</a>.
This call is only effective on Linux and returns LIBUSB_ERROR_NOT_SUPPORTED
on all other platforms.</p>
<p>This functionality is not available on Darwin or Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to attach the driver from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if no kernel driver was active </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM if the interface does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not
available </dd>
<dd>
LIBUSB_ERROR_BUSY if the driver cannot be attached because the interface is
claimed by a program or driver </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el"
href="group__libusb__dev.html#ga1cabd4660a274f715eeb82de112e0779">libusb_kernel_driver_active()</a> </dd></dl>

</div>
</div>
<a id="gac35b26fef01271eba65c60b2b3ce1cbf"></a>
<h2 class="memtitle"><span class="permalink"><a
href="group__libusb__dev.html#gac35b26fef01271eba65c60b2b3ce1cbf">&#9670;&nbsp;</a></span>libusb_set_auto_detach_kernel_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_set_auto_detach_kernel_driver </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/disable libusb's automatic kernel driver detachment. When this is
enabled libusb will automatically detach the kernel driver on an interface
when claiming the interface, and attach it when releasing the interface.</p>
<p>Automatic kernel driver detachment is disabled on newly opened device
handles by default.</p>
<p>On platforms which do not have LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER this
function will return LIBUSB_ERROR_NOT_SUPPORTED, and libusb will continue as
if this function was never called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
    <tr><td class="paramname">enable</td><td>whether to enable or disable auto kernel driver detachment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LIBUSB_SUCCESS on success </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not
available </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el"
href="group__libusb__dev.html#gaee5076addf5de77c7962138397fd5b1a">libusb_claim_interface()</a> </dd>
<dd>
<a class="el"
href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa">libusb_release_interface()</a> </dd>
<dd>
<a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a> </dd></dl>

</div>
</div>
</div>
<!-- contents -->
<div class="ttc" id="agroup__libusb__dev_html_gac0fe4b65914c5ed036e6cbec61cb0b97"><div class="ttname"><a
href="group__libusb__dev.html#gac0fe4b65914c5ed036e6cbec61cb0b97">libusb_get_device_list</a></div><div class="ttdeci">ssize_t libusb_get_device_list(libusb_context *ctx, libusb_device ***list)</div><div class="ttdef"><b>Definition:</b> core.c:825</div></div>
<div class="ttc" id="agroup__libusb__dev_html_ga77eedd00d01eb7569b880e861a971c2b"><div class="ttname"><a
href="group__libusb__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a></div><div class="ttdeci">struct libusb_device libusb_device</div><div class="ttdef"><b>Definition:</b> libusb.h:1004</div></div>
<div class="ttc" id="agroup__libusb__dev_html_ga3f184a8be4488a767b2e0ae07e76d1b0"><div class="ttname"><a
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open</a></div><div class="ttdeci">int libusb_open(libusb_device *dev, libusb_device_handle **dev_handle)</div><div class="ttdef"><b>Definition:</b> core.c:1302</div></div>
<div class="ttc" id="agroup__libusb__dev_html_gad3b8561d064bb3e1b8851ddeed3cd7d6"><div class="ttname"><a
href="group__libusb__dev.html#gad3b8561d064bb3e1b8851ddeed3cd7d6">libusb_free_device_list</a></div><div class="ttdeci">void libusb_free_device_list(libusb_device **list, int unref_devices)</div><div class="ttdef"><b>Definition:</b> core.c:895</div></div>
<div class="ttc" id="agroup__libusb__dev_html_ga7df95821d20d27b5597f1d783749d6a4"><div class="ttname"><a
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a></div><div class="ttdeci">struct libusb_device_handle libusb_device_handle</div><div class="ttdef"><b>Definition:</b> libusb.h:1015</div></div>

<!-- start footer part -->
<hr class="footer"/><address class="footer"><small> Generated on Thu Dec 10 2020 11:03:33 for libusb by &#160;<a
href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17 </small></address>
</body>
</html>
