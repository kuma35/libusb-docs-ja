<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libusb: 非同期デバイス入出力</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libusb &#160;<span id="projectnumber">1.0.24</span>
   </div>
   <div id="projectbrief">USBデバイスにアクセスするためのクロス・プラットフォームのユーザー・ライブラリ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>


<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license
magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt
GPL-v2 */ $(function() { initMenu('',false,false,'search.php','Search'); });
/* @license-end */</script>
<div id="main-nav"></div>
</div>
<!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124; <a
href="#typedef-members">Typedefs</a> &#124; <a href="#enum-members">列挙型</a>
&#124; <a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">非同期デバイス入出力</div>  </div>
</div>
<!--header-->
<div class="contents">

<p>このページでは、USBデバイス入出力用のlibusbの非同期(非ブロッキング)APIについて詳しく説明します。
このインターフェイスは非常に強力ですが、非常に複雑でもあります。このページを注意深く読んで、このインターフェイスの使用に関する必要な考慮事項と問題を理解する必要があります。単純なアプリケーションでは、代わりに
<a class="el" href="group__libusb__syncio.html">同期入出力API</a>
を検討することをお勧めします。<a href="#details">詳細はコチラ</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> データ構造</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="structlibusb__control__setup.html">libusb_control_setup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="structlibusb__iso__packet__descriptor.html">libusb_iso_packet_descriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibusb__transfer.html">libusb_transfer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a> Typedef</h2></td></tr>
<tr class="memitem:gac74874519794cd7aa40c0814702b0c88"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>)
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer)</td></tr>
<tr class="separator:gac74874519794cd7aa40c0814702b0c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a> 列挙型</h2></td></tr>
<tr class="memitem:gacb52027036a07de6ecc6c2bf07d07c71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gacb52027036a07de6ecc6c2bf07d07c71">libusb_transfer_type</a>
{ <br />
&#160;&#160;<a class="el"
href="group__libusb__asyncio.html#ggacb52027036a07de6ecc6c2bf07d07c71a4c89624658c783ef9b2a2f08091bc7d7">LIBUSB_TRANSFER_TYPE_CONTROL</a>
= 0U, <a class="el"
href="group__libusb__asyncio.html#ggacb52027036a07de6ecc6c2bf07d07c71a40de9889554fc1785d784b3c31333300">LIBUSB_TRANSFER_TYPE_ISOCHRONOUS</a>
= 1U, <a class="el"
href="group__libusb__asyncio.html#ggacb52027036a07de6ecc6c2bf07d07c71a7bdfa2fc5dadbaaa0e9262e1b4a228e2">LIBUSB_TRANSFER_TYPE_BULK</a>
= 2U, <a class="el"
href="group__libusb__asyncio.html#ggacb52027036a07de6ecc6c2bf07d07c71aefb0e07862c0eed894ec9c2f957a7e3c">LIBUSB_TRANSFER_TYPE_INTERRUPT</a>
= 3U, 
<br />
&#160;&#160;<a class="el"
href="group__libusb__asyncio.html#ggacb52027036a07de6ecc6c2bf07d07c71a3b26ee40f9c586ece75f8de822d974e3">LIBUSB_TRANSFER_TYPE_BULK_STREAM</a>
= 4U
<br />
 }</td></tr>
<tr class="separator:gacb52027036a07de6ecc6c2bf07d07c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fcb2aa23d342060ebda1d0cf7478856"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga9fcb2aa23d342060ebda1d0cf7478856">libusb_transfer_status</a>
{ <br />
&#160;&#160;<a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a4595f6532aab12352a58a0fd4ce48363">LIBUSB_TRANSFER_COMPLETED</a>,
<a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856aa8852ed719d03c2a3cc6f0312d919398">LIBUSB_TRANSFER_ERROR</a>,
<a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856ac2b7626d7b51cb980f83933b6ada1ddf">LIBUSB_TRANSFER_TIMED_OUT</a>,
<a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a8af1f19e46cccafdcf3feadce47e880b">LIBUSB_TRANSFER_CANCELLED</a>, 
<br />
&#160;&#160;<a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a23cdfd929f5fe82cca9654f8075eeebb">LIBUSB_TRANSFER_STALL</a>,
<a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856ab7dcb24f313ace407e0c070d6b2c5f13">LIBUSB_TRANSFER_NO_DEVICE</a>,
<a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856ab1b9cbcb1de27a8fbeceb3427fb2fb14">LIBUSB_TRANSFER_OVERFLOW</a>
<br />
 }</td></tr>
<tr class="separator:ga9fcb2aa23d342060ebda1d0cf7478856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb47dd0f7c209b60a3609ff0c03d56d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga1fb47dd0f7c209b60a3609ff0c03d56d">libusb_transfer_flags</a>
{ <a class="el"
href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae4c0697c266819c51c1734b3456e7276">LIBUSB_TRANSFER_SHORT_NOT_OK</a>
= (1U &lt;&lt; 0), <a class="el"
href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86">LIBUSB_TRANSFER_FREE_BUFFER</a>
= (1U &lt;&lt; 1), <a class="el"
href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dacf3f064997b283a14097c9f4d6f8ccc1">LIBUSB_TRANSFER_FREE_TRANSFER</a>
= (1U &lt;&lt; 2), <a class="el"
href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56da26b66334b6ec0537c49841ca623d901f">LIBUSB_TRANSFER_ADD_ZERO_PACKET</a>
= (1U &lt;&lt; 3)  }</td></tr>
<tr class="separator:ga1fb47dd0f7c209b60a3609ff0c03d56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a> 関数</h2></td></tr>
<tr class="memitem:gad7e786c1bedd4a668887564465101981"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981">libusb_alloc_streams</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, uint32_t num_streams, unsigned char *endpoints, int
num_endpoints)</td></tr>
<tr class="separator:gad7e786c1bedd4a668887564465101981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab068de0fd203ccef5c620a8143526acb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gab068de0fd203ccef5c620a8143526acb">libusb_free_streams</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, unsigned char *endpoints, int num_endpoints)</td></tr>
<tr class="separator:gab068de0fd203ccef5c620a8143526acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c492e750197f1a28874c7a0dee40e3"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga47c492e750197f1a28874c7a0dee40e3">libusb_dev_mem_alloc</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, size_t length)</td></tr>
<tr class="separator:ga47c492e750197f1a28874c7a0dee40e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7575ff325f0159a5b74b7c0ee64eb62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gad7575ff325f0159a5b74b7c0ee64eb62">libusb_dev_mem_free</a>
(<a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, unsigned char *buffer, size_t length)</td></tr>
<tr class="separator:gad7575ff325f0159a5b74b7c0ee64eb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13cc69ea40c702181c430c950121c000"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer</a>
(int iso_packets)</td></tr>
<tr class="separator:ga13cc69ea40c702181c430c950121c000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab8b2cff4de9091298a06b2f4b86cd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6">libusb_free_transfer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer)</td></tr>
<tr class="separator:ga6ab8b2cff4de9091298a06b2f4b86cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb0932601f2c7dad2fee4b27962848ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer)</td></tr>
<tr class="separator:gabb0932601f2c7dad2fee4b27962848ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685eb7731f9a0593f75beb99727bbe54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga685eb7731f9a0593f75beb99727bbe54">libusb_cancel_transfer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer)</td></tr>
<tr class="separator:ga685eb7731f9a0593f75beb99727bbe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae2db23b9de811af317483afdeb230f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gaeae2db23b9de811af317483afdeb230f">libusb_transfer_set_stream_id</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, uint32_t stream_id)</td></tr>
<tr class="separator:gaeae2db23b9de811af317483afdeb230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631653487273f3306925131cdc0a3ffc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga631653487273f3306925131cdc0a3ffc">libusb_transfer_get_stream_id</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer)</td></tr>
<tr class="separator:ga631653487273f3306925131cdc0a3ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9c633586dde54ce62a3d66a4d7554c"><td class="memItemLeft" align="right" valign="top">static unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gadf9c633586dde54ce62a3d66a4d7554c">libusb_control_transfer_get_data</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer)</td></tr>
<tr class="separator:gadf9c633586dde54ce62a3d66a4d7554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab02f15e11b5b03b1174fbd7c3bc061"><td class="memItemLeft" align="right" valign="top">static struct <a class="el"
href="structlibusb__control__setup.html">libusb_control_setup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga6ab02f15e11b5b03b1174fbd7c3bc061">libusb_control_transfer_get_setup</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer)</td></tr>
<tr class="separator:ga6ab02f15e11b5b03b1174fbd7c3bc061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5447311149ec2bd954b5f1a640a8e231"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup</a>
(unsigned char *buffer, uint8_t bmRequestType, uint8_t bRequest, uint16_t
wValue, uint16_t wIndex, uint16_t wLength)</td></tr>
<tr class="separator:ga5447311149ec2bd954b5f1a640a8e231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8513ed87229fe2c9771ef0bf17206e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e">libusb_fill_control_transfer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, unsigned char *buffer, <a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>
callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="separator:ga3a8513ed87229fe2c9771ef0bf17206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ddb1a5c6c7fefc979a44d7300b95d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gad4ddb1a5c6c7fefc979a44d7300b95d7">libusb_fill_bulk_transfer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, unsigned char endpoint, unsigned char *buffer, int length, <a
class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>
callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="separator:gad4ddb1a5c6c7fefc979a44d7300b95d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e84d8fb9218d3c67e6a4fd4ade5b10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gac2e84d8fb9218d3c67e6a4fd4ade5b10">libusb_fill_bulk_stream_transfer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, unsigned char endpoint, uint32_t stream_id, unsigned char
*buffer, int length, <a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>
callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="separator:gac2e84d8fb9218d3c67e6a4fd4ade5b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f53cea1124a7566df1aa1202b77510"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga90f53cea1124a7566df1aa1202b77510">libusb_fill_interrupt_transfer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, unsigned char endpoint, unsigned char *buffer, int length, <a
class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>
callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="separator:ga90f53cea1124a7566df1aa1202b77510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fdce8c461e851f0aa4c851014e1aa7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga30fdce8c461e851f0aa4c851014e1aa7">libusb_fill_iso_transfer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, <a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*dev_handle, unsigned char endpoint, unsigned char *buffer, int length, int
num_iso_packets, <a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>
callback, void *user_data, unsigned int timeout)</td></tr>
<tr class="separator:ga30fdce8c461e851f0aa4c851014e1aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbdecd6f50093f0c1d0e72ee35ace274"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#gacbdecd6f50093f0c1d0e72ee35ace274">libusb_set_iso_packet_lengths</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, unsigned int length)</td></tr>
<tr class="separator:gacbdecd6f50093f0c1d0e72ee35ace274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6ea0eb35a216d19d984977e454a7b3"><td class="memItemLeft" align="right" valign="top">static unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga7f6ea0eb35a216d19d984977e454a7b3">libusb_get_iso_packet_buffer</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, unsigned int packet)</td></tr>
<tr class="separator:ga7f6ea0eb35a216d19d984977e454a7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3df9a28c4f5c8f1850181ddb5efd12fd"><td class="memItemLeft" align="right" valign="top">static unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd">libusb_get_iso_packet_buffer_simple</a>
(struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer, unsigned int packet)</td></tr>
<tr class="separator:ga3df9a28c4f5c8f1850181ddb5efd12fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳細</h2>
<p>このページでは、USBデバイス入出力O用のlibusbの非同期(非ブロッキング)APIについて詳しく説明します。
このインターフェイスは非常に強力ですが、非常に複雑でもあります。このページを注意深く読んで、このインターフェイスの使用に関する必要な考慮事項と問題を理解する必要があります。
単純なアプリケーションでは、代わりに <a class="el"
href="group__libusb__syncio.html">同期入出力API</a> を検討することをお勧めします。 </p>
<p>非同期インターフェースは、転送の送信と転送の完了の処理を分離するという考えに基づいて構築されています(同期モデルはこれらの両方を1つに結合します)。
送信から完了までに長い遅延が発生する可能性がありますが、非同期送信機能は非ブロッキングであるため、その潜在的に長い遅延の間にアプリケーションに制御を戻します。</p>
<h1><a class="anchor" id="asyncabstraction"></a> 転送の抽象化</h1>
<p>非同期入出力の場合、libusbは、すべてのタイプの入出力(制御、バルク、割り込み、アイソクロナス)の汎用転送エンティティの概念を実装します。汎用転送オブジェクトは、それを使用して実行している入出力のタイプに応じて、多少異なる方法で処理する必要があります。</p>
<p>これは、 public <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a> 構造体タイプで表されます。</p>
<h1><a class="anchor" id="asynctrf"></a> 非同期転送</h1>
<p>非同期入出力は5ステップのプロセスと見なすことができます:</p><ol type="1">
<li><b>割り当て</b>: <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a> を割り当てます</li>
<li><b>情報入力</b>: その <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a>
インスタンスに実行したい転送に関する情報を入力します</li>
<li><b>送信</b>: libusbに送信(submit)を依頼する</li>
<li><b>完了処理</b>: <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a> 構造体で転送結果を調べます</li>
<li><b>割り当て解除</b>: リソースをクリーンアップします</li>
</ol>
<h2><a class="anchor" id="asyncalloc"></a> 割り当て</h2>
<p>このステップには、USB転送用のメモリの割り当てが含まれます。
これは、前述した一般的な転送オブジェクトです。この段階では、転送は「空白」であり、使用される入出力タイプに関する詳細はありません。</p>
<p>割り当ては、 <a class="el"
href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer()</a>
関数を使用して行われます。 あなた独自の転送の割り当てではなく、この関数を使用する必要があります。</p>
<h2><a class="anchor" id="asyncfill"></a> 情報入力</h2>
<p>このステップでは、先程割り当てられた転送を取得し、メッセージ・タイプと方向(訳注:入力か出力か)、データ・バッファー、コールバック関数などの情報を入力します。</p>
<p>あなたは必要なフィールドに自分で入力するか、ヘルパー関数を使用できます: <a class="el"
href="group__libusb__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e">libusb_fill_control_transfer()</a>
と <a class="el"
href="group__libusb__asyncio.html#gad4ddb1a5c6c7fefc979a44d7300b95d7">libusb_fill_bulk_transfer()</a>
と <a class="el"
href="group__libusb__asyncio.html#ga90f53cea1124a7566df1aa1202b77510">libusb_fill_interrupt_transfer()</a></p>
<h2><a class="anchor" id="asyncsubmit"></a> 送信</h2>
<p>転送を割り当て、入力したら、 <a class="el"
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer()</a>
を使用して送信できます。この関数はすぐに戻りますが、バックグラウンドで入出力要求を実行しています。</p>
<h2><a class="anchor" id="asynccomplete"></a> 完了処理</h2>
<p>転送データを送信開始した後、次の4つのいずれかが発生する可能性があります:</p>
<ul>
<li>転送が完了しました(つまり、いくつかのデータが転送されました)</li>
<li>転送にはタイムアウトがあり、すべてのデータが転送される前にタイムアウトが期限切れになる事があります</li>
<li>エラーが原因で転送が失敗</li>
<li>転送処理がキャンセルされた</li>
</ul>
<p>これらそれぞれに対してユーザー指定の転送コールバック関数が呼び出されます。上記のどれが実際に起こったかを判断し、それに応じて行動するのはコールバック関数次第です。</p>
<p>ユーザー指定のコールバックには、転送の情報入力時と送信時に使用された <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a> 構造体へのポインタが渡されます。
完了時にlibusbはこの構造体に転送の結果(成功または失敗の理由、転送されたデータのバイト数など)を入力します。詳細については、 <a
class="el" href="structlibusb__transfer.html">libusb_transfer</a>
構造体の文書を参照してください。</p>
<p><b>重要</b>:
ユーザー指定のコールバックは、イベント処理コンテキストから呼び出されます。したがって、イベント処理を実行しようとするlibusbへの呼び出しが行われないことが重要です。このような関数の例としては、
<a class="el" href="group__libusb__syncio.html">同期API</a> にリストされているものや、 <a
class="el" href="group__libusb__desc.html">USBデスクリプター</a>
を取得するブロッキング関数があります。</p>
<h2><a class="anchor" id="Deallocation"></a> 割り当て解除</h2>
<p>転送が完了したら(つまり、コールバック関数が呼び出されたら)、その転送を解放することをお勧めします(再送信する場合を除き、以下を参照してください)。
転送は、 <a class="el"
href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6">libusb_free_transfer()</a>
で割り当て解除されます。</p>
<p>完了していない転送を解放することは未定義の動作です。</p>
<h1><a class="anchor" id="asyncresubmit"></a> 再送信</h1>
<p>これらを1つの操作に合理的に組み合わせることができるのに、割り当て・情報入力・送信がすべて分離されているのはなぜか疑問に思われるかもしれません。</p>
<p>分離してある理由は、毎回新しい転送を割り当てることなく、転送を再送信できるようにするためです。
これは、割り込みエンドポイントを扱う一般的な状況で特に役立ちます。1つの転送を割り当て、それを入力して送信し、結果が返されたら、次の割り込みのために再送信するだけです。</p>
<h1><a class="anchor" id="asynccancel"></a> キャンセル</h1>
<p>非同期インターフェースを使用するもう1つの利点は、まだ完了していない転送をキャンセルできることです。 これは、 <a class="el"
href="group__libusb__asyncio.html#ga685eb7731f9a0593f75beb99727bbe54">libusb_cancel_transfer()</a>
関数を呼び出すことで実行されます。</p>
<p><a class="el"
href="group__libusb__asyncio.html#ga685eb7731f9a0593f75beb99727bbe54">libusb_cancel_transfer()</a>
それ自体が非同期/非ブロッキングです。
キャンセルが実際に完了すると、転送のコールバック関数が呼び出され、コールバック関数は転送ステータスをチェックして、キャンセルされたことを確認する必要があります。</p>
<p>キャンセル後、キャンセルが完了する前に転送を解放すると、未定義の動作が発生します。</p>
<dl class="section attention"><dt>注意</dt><dd>転送がキャンセルされた場合、一部のデータが転送された可能性があります。 libusbは、転送コールバックでこれを通知します。
<b>転送されたデータ無かったという想定はしないでください。</ b></dd></dl>
<h1><a class="anchor" id="asyncpartial"></a> キャンセルによる部分的なデータ転送</h1>
<p>上記のように、一部のデータは転送がキャンセルされたときに既に転送された可能性があります。
パケット・サイズが64バイトのエンドポイントへの一括転送を検討する場合、これがどのように可能であるかを確認すると役立ちます。このエンドポイントに512バイトの転送を送信すると、オペレーティング・システムは、この転送を8つの個別の64バイトフレームに分割し、ホスト・コントローラーがデバイスがデータを転送するようにスケジュールします。
デバイスがデータを転送しているときにこの転送がキャンセルされた場合、デバイスがホストへのデータの転送を完了する前に、これらのフレームの部分がホスト・コントローラーからスケジュール解除される可能性があります。</p>
<p>部分的なデータ転送でアプリケーションが行うべきことは、ポリシーの決定です。 すべてのアプリケーションの需要を満たす単一の答えはありません。
正常に転送されたデータは完全に有効であると見なす必要があります。しかし、アプリケーションは、転送されなかった残りのデータをどう処理するかを決定する必要があります。実行できる行動は以下のとおりです:</p><ul>
<li>残りのデータの別の転送を再送信します。タイムアウトを短くすることもできます</li>
<li>部分的に転送されたデータを破棄し、エラーを報告します</li>
</ul>
<h1><a class="anchor" id="asynctimeout"></a> タイムアウト</h1>
<p>転送がタイムアウトすると、libusbはこれを内部的に記録し、転送をキャンセルしようとします。 <a class="el"
href="group__libusb__asyncio.html#asyncpartial">上述e</a>されているように、一部のデータは実際に転送された可能性があります。アプリケーションは、転送が完了したら、<b>常に</b>実際に転送されたデータの量を確認し、それに応じて動作する必要があります。</p>
<h1><a class="anchor" id="bulk_overflows">
デバイスからホスト方向のバルクまたは割り込みエンドポイントでのオーバーフロー</h1>
<p>デバイスに推測可能な転送サイズがない場合(またはデバイスが誤動作する場合)、アプリケーションは、デバイスが送信したいデータよりも小さいINエンドポイントでデータの要求を送信する場合があります。状況によっては、これによりオーバーフローが発生し、対処するのが厄介な状態になります。この議論については、
<a class="el" href="libusb_packetoverflow.html">パケットとオーバーフロー</a>
ページを参照してください。</p>
<h1><a class="anchor" id="asyncctrl"></a> 制御転送に関する考慮</h1>
<p><code><a class="el"
href="structlibusb__transfer.html">libusb_transfer</a></code>
構造は汎用であるため、制御転送固有のセットアップ・パケット構造体の特定のフィールドは含まれていません。</p>
<p>制御転送を実行するには、8バイトのセットアップ・パケットをデータ・バッファの先頭に配置する必要があります。これを単純化するために、バッファ・ポインタを型
struct  にキャストするか、ヘルパー関数 <a class="el"
href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup()</a>
を使用できます。</p>
<p>セットアップ・パケットに配置されるwLengthフィールドは、セットアップ・パケットで送信されると予想される長さ、つまり後続のペイロードの長さ(または受信すると予想される最大バイト数)である必要があります。
ただし、 <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
オブジェクトのlengthフィールドは、データ・バッファの長さである必要があります。つまり、wLengthにセットアップ・パケットのサイズを<em>加えた</em>ものである必要があります(LIBUSB_CONTROL_SETUP_SIZE)。</p>
<p>ヘルパー関数を使用する場合、これは以下のように単純化されます:</p><ol type="1">
<li>サイズ値LIBUSB_CONTROL_SETUP_SIZEに、送信/要求するデータのサイズを加えて、バッファーを割り当てます。</li>
<li>転送要求のサイズをwLength値として使用して、データ・バッファーで <a class="el"
href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup()</a>
を呼び出します(つまり、制御転送セットアップに割り当てた余分なスペースを含めないでください)。</li>
<li>これがホストからデバイス方向の転送である場合は、オフセットLIBUSB_CONTROL_SETUP_SIZEから開始して、転送するデータをデータ・バッファーに配置します。</li>
<li><a class="el"
href="group__libusb__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e">libusb_fill_control_transfer()</a>
を呼び出して、データ・バッファーを転送に関連付けます(そして、コールバックやタイムアウトなどの残りの詳細を設定します)。<ul>
<li>注意: 転送の長さフィールドを設定するパラメータがないことに注意してください。
長さは、セットアップ・パケットのwLengthフィールドから自動的に推測されます。</li>
</ul>
</li>
<li>その転送を送信する。</li>
</ol>
<p>マルチバイト制御セットアップ・フィールド( wValue と wIndex と wLength
)は、リトル・エンディアンのバイト順序(USBバスのエンディアン)で指定する必要があります。エンディアン変換は、ホスト・エンディアン値を受け入れるように文書化されている
<a class="el"
href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup()</a>
によって透過的に処理されます。</p>
<p>コールバック関数で転送の完了を処理する場合は、さらに考慮が必要です。</p><ul>
<li>ご存知のとおり、セットアップ・パケットはデータ・バッファの先頭にあります。</li>
<li>これがデバイスからホスト方向への転送であった場合、受信したデータはオフセットLIBUSB_CONTROL_SETUP_SIZE位置からバッファーに格納されます。</li>
<li>転送構造体のactual_lengthフィールドは、データ・バッファのサイズではなく、セットアップ・パケットのwLengthに関連しています。
したがって、wLengthが4の場合、転送の <code>length</code> は12であり、データが完全に転送されたことを示す
<code>actual_length</code> が4であると予想する必要があります。</li>
</ul>
<p>セットアップパケットの解析と正しいオフセットからのデータの取得を簡素化するために、転送コールバック内で <a class="el"
href="group__libusb__asyncio.html#gadf9c633586dde54ce62a3d66a4d7554c">libusb_control_transfer_get_data()</a>
関数と <a class="el"
href="group__libusb__asyncio.html#ga6ab02f15e11b5b03b1174fbd7c3bc061">libusb_control_transfer_get_setup()</a>
関数を使用することをお勧めします。</p>
<p>制御エンドポイントが停止しない場合でも、完了した制御転送にはLIBUSB_TRANSFER_STALLステータス・コードが含まれる場合があります。これは、制御要求がサポートされていなかったことを示します。</p>
<h1><a class="anchor" id="asyncintr"></a> 割り込み転送に関する考慮</h1>
<p>すべての割り込み転送は、エンドポイント・デスクリプターのbInterval値によって示されるポーリング間隔を使用して実行されます。</p>
<h1><a class="anchor" id="asynciso"></a> アイソクロナス転送に関する考慮</h1>
<p>アイソクロナス転送は、非アイソクロナス・エンドポイントへの転送よりも更に複雑です。</p>
<p>アイソクロナス・エンドポイントへの入出力を実行するには、適切な数のアイソクロナス・パケットを使用して <a class="el"
href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer()</a>
を呼び出して転送を割り当てます。</p>
<p>情報入力で、 <a class="el"
href="structlibusb__transfer.html#a7c9fa575986fe9f23bbecb26b766dff1">type</a>
に <a class="el"
href="group__libusb__asyncio.html#ggacb52027036a07de6ecc6c2bf07d07c71a40de9889554fc1785d784b3c31333300">LIBUSB_TRANSFER_TYPE_ISOCHRONOUS</a>
をセットし、 <a class="el"
href="structlibusb__transfer.html#a87d725a5521c26832fdc13611220014d">num_iso_packets</a>
に割り当て中に要求したパケット数以下の値をセットします。 <a class="el"
href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer()</a>
は、アイソクロナス・エンドポイントで転送を使用しない可能性があるため、これらのフィールドのどちらも設定しません。</p>
<p>次に、 <a class="el"
href="structlibusb__transfer.html#a3b72ef736d32b94a7097798612741644">iso_packet_desc</a>
配列の最初のnum_iso_packetsエントリのlengthフィールドに入力します。 USB2仕様の5.6.3節(Section 5.6.3 of
the USB2
specifications)では、エンドポイント・デスクリプターのwMaxPacketSizeフィールドによって最大アイソクロナス・パケット長がどのように決定されるかについて説明しています。ここで以下の2つの機能が役に立ちます:</p>
<ul>
<li><a class="el"
href="group__libusb__dev.html#gaec10b71c7209760db55ee0f8768bb4f0">libusb_get_max_iso_packet_size()</a>
は、アイソクロナス・エンドポイントの最大パケット・サイズを決定する簡単な方法です。最大パケットサイズは、実際には1つのマイクロ・フレームで送信できる最大バイト数であるため、この関数は、トランザクションあたりの最大バイト数にマイクロフレームあたりの取引機会の数(number
of transaction opportunities)を掛けることに注意してください。</li>
<li><a class="el"
href="group__libusb__asyncio.html#gacbdecd6f50093f0c1d0e72ee35ace274">libusb_set_iso_packet_lengths()</a>
は、転送内のすべてのパケットに同じ長さを割り当てます。これは通常、あなたが必要としている事です。</li>
</ul>
<p>こちらから相手への発信する転送の場合、すべてのデータが転送されることを期待して、あなたは確実にバッファを埋め、パケット・デスクリプターを入力します。逆に着信転送の場合、すべてのパケットが要求されたデータの全量を転送する状況に対して、バッファーに十分な容量があることを確認する必要があります。</p>
<p>完了処理には、追加の考慮事項が必要です。 転送の <a class="el"
href="structlibusb__transfer.html#a7e858f07c48a271a62209d11376ae607">actual_length</a>
フィールドは無意味であるため、調べる必要はありません。 代わりに、個々のパケットの <a class="el"
href="structlibusb__iso__packet__descriptor.html#a03fa4f4eaf8a8b4e5c05931809581a32">actual_length</a>
フィールドを参照する必要があります。</p>
<p>転送の <a class="el"
href="structlibusb__transfer.html#a64b2e70e76d52a7cd23daa3cd4fb397e">status</a>
フィールドも少々誤解を招く可能性があります:</p><ul>
<li>パケットが送信され、アイソクロナス・データ・マイクロ・フレームが正常に完了した場合、 status の値は <a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856a4595f6532aab12352a58a0fd4ce48363">LIBUSB_TRANSFER_COMPLETED</a>
になります。 バス・エラーと、ソフトウェアで発生した遅延は、転送エラーとしてカウントされないことに注意してください。 transfer.status
フィールドは、パケットの一部またはすべてが失敗した場合でも COMPLETED を示す場合があります。 個々のパケットの <a class="el"
href="structlibusb__iso__packet__descriptor.html#aab21ee2a5835a0e53d7ac5844ee34371">status</a>
フィールドを参照して、パケットの障害を特定します。</li>
<li>status フィールドの値は、重大なエラーが発生した場合にのみ <a class="el"
href="group__libusb__asyncio.html#gga9fcb2aa23d342060ebda1d0cf7478856aa8852ed719d03c2a3cc6f0312d919398">LIBUSB_TRANSFER_ERROR</a>
になります。</li>
<li>その他の転送ステータス・コードは、通常の動作で発生します。</li>
</ul>
<p>各パケットのデータは、その直前のパケットが完全に完了したはずの位置で見つかります。 <a class="el"
href="group__libusb__asyncio.html#ga7f6ea0eb35a216d19d984977e454a7b3">libusb_get_iso_packet_buffer()</a>
関数と <a class="el"
href="group__libusb__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd">libusb_get_iso_packet_buffer_simple()</a>
関数が役に立つ事でしょう。</p>
<h1><a class="anchor" id="asynclimits"></a> 転送長さ制限</h1>
<p>一部のオペレーティング・システムでは、転送データ・バッファの長さ、またはアイソクロナス転送の場合は個々のアイソクロナス・パケットの長さに制限を課す場合があります。このような制限はlibusbが検出するのが難しい場合があるため、ほとんどの場合、ライブラリはユーザーが設定した転送で送信しようとします。転送が大きすぎるために送信に失敗した場合、
<a class="el"
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer()</a>
は <a class="el"
href="group__libusb__misc.html#ggab2323aa0f04bc22038e7e1740b2f29efa680e4bf39b66a36be3182be3ebf58062">LIBUSB_ERROR_INVALID_PARAM</a>
を返します。</p>
<p>以下は、制御転送長の既知の制限です。この長さには、8バイトのセットアップ・パケットが含まれていることに注意してください。</p><ul>
<li>Linux (4,096 bytes)</li>
<li>Windows (4,096 bytes)</li>
</ul>
<h1><a class="anchor" id="asyncmem"></a> メモリに関する警告</h1>
<p>ほとんどの場合、転送バッファにスタック・メモリを使用することは安全ではありません。これは、非同期転送を開始した関数が、libusbがバッファーの使用を終了する前に戻る可能性があり、関数が戻ると、そのスタックは破棄されるためです。これは、ホストからデバイスへの転送とデバイスからホストへの転送の両方に当てはまります。</p>
<p>スタック・メモリを安全に使用できる唯一のケースは、バッファのスタック・スペースを所有する関数が、転送のコールバック関数が完了するまで戻らないことを保証できる場合です。それ以外の場合は、代わりにヒープ・メモリを使用する必要があります。</p>
<h1><a class="anchor" id="asyncflags"></a> 繊細な制御</h1>
<p>この非同期インターフェースを使用すると、いくつかの簡単な操作を何度も繰り返すことに気付くかもしれません。転送でflagの特定のビットごとのORをセットして、特定の操作を単純化できます:</p><ul>
<li>LIBUSB_TRANSFER_SHORT_NOT_OKは、要求された量より少ないデータしか転送しなかった場合で、
statusがLIBUSB_TRANSFER_ERRORの場合にセットされる事があります(通常は完了(COMPLETED)と見なされます)。</li>
<li><a class="el"
href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86">LIBUSB_TRANSFER_FREE_BUFFER</a>
を使用すると、転送を解放するときにlibusbに転送バッファーを解放するように要求できます。</li>
<li><a class="el"
href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dacf3f064997b283a14097c9f4d6f8ccc1">LIBUSB_TRANSFER_FREE_TRANSFER</a>
により、libusbは転送後に転送を自動的に解放します。</li>
</ul>
<h1><a class="anchor" id="asyncevent"></a> イベント処理</h1>
<p>非同期モデルでは、libusbがさまざまな時点で作業を実行する必要があります。つまり、以前に送信された転送の結果を処理し、ユーザーが指定したコールバック関数を呼び出します。</p>
<p>これにより、libusbが機能するときにあなたのアプリケーションが呼び出す必要のある <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
関数が生起されます。これにより、libusbは保留中の転送を取得したり、コールバックを呼び出したりすることができます。</p>
<dl class="section note"><dt>注意</dt><dd>すべてのイベント処理は、 <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
関数を呼び出すスレッドによって実行されます。 libusbは、このコンテキスト以外でコールバックを呼び出しません。したがって、コールバックはすべて、
<a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
関数を呼び出すスレッドで実行されます。</dd></dl>
<p><a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
関数をいつ呼び出すかは、あなたのアプリケーションが使用することを決定したモデルによって異なります。2つの異なるアプローチがあります:</p>
<ol type="1">
<li>専用スレッドからブロッキング・モードで繰り返し <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
を呼び出します。</li>
<li>libusbをアプリケーションのメイン・イベント・ループと統合します。 libusbは、これを可能にする一連のファイル・デスクリプターを公開します。</li>
</ol>
<p>最初のアプローチには、選択/ポーリング統合用のlibusbのポーリングAPIが利用できない場合にWindowsでも機能するという大きな利点があります。
したがって、Windowsをサポートして非同期APIを使用する場合は、このアプローチを使用する必要があります。詳細については、以下の <a
class="el" href="group__libusb__asyncio.html#eventthread">イベント処理スレッドの利用</a>
を参照してください。</p>
<p>単一の中央イベント・ループを使用するシングル・スレッド・アプローチが必要な場合は、libusbをアプリケーションのメイン・イベント・ループに統合する方法について、
<a class="el" href="group__libusb__poll.html">ポーリングとタイミング</a> の節を参照してください。</p>
<h1><a class="anchor" id="eventthread"></a> 単一のイベント処理スレッドの使用</h1>
<p>まず、明白であることから言うと、libusbイベント処理に別のスレッドを使用する場合、コールバック関数はスレッド・セーフでなければなりません。</p>
<p>それ以外の場合、別のスレッドからイベント処理を行うのは割と簡単です。イベント・スレッド関数は以下のように使用できます: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> *event_thread_func(<span
class="keywordtype">void</span> *ctx)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span> (event_thread_run)</div>
<div class="line">        <a class="code"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events</a>(ctx);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>ただし、注意点が1つあります。このスレッドを停止するには、event_thread_run変数を0に設定する必要があります。その後、 <a
class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
は制御をevent_thread_funcに戻す必要があります。 ただし、何らかのイベントが発生しない限り、 <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
は処理を返しません。</p>
<p>アプリケーションがlibusbの <a class="el" href="libusb_hotplug.html">活線挿抜(hotplug)</a>
サポートを使用しているかどうかに応じて、これに対処する2つの異なる方法があります。</p>
<p>活線挿抜(hotplug)サポートを使用しないアプリケーションは、 <a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
を最初に呼び出した直後まで、イベント・スレッドを開始しないでください。また、以下のように最後、オープンしていたデバイスをクローズしたときにスレッドを停止する必要があります: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_close_handle(<a class="code"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*<a class="code"
href="structlibusb__transfer.html#adaaf06aeb5ab2a8819e75310ec253f7a">dev_handle</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (open_devs == 1)</div>
<div class="line">        event_thread_run = 0;</div>
<div class="line"> </div>
<div class="line">    <a class="code"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close</a>(<a
class="code"
href="structlibusb__transfer.html#adaaf06aeb5ab2a8819e75310ec253f7a">dev_handle</a>);
<span class="comment">// This wakes up libusb_handle_events()</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (open_devs == 1)</div>
<div class="line">        pthread_join(event_thread);</div>
<div class="line"> </div>
<div class="line">    open_devs--;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>活線挿抜サポートを使用するアプリケーションは、 <a class="el"
href="group__libusb__hotplug.html#ga5ab3955e2110a3099497a66256fb7fab">libusb_hotplug_register_callback()</a>
を正常に呼び出した後、プログラムのinitでスレッドを開始し、以下のとおりプログラムの終了時にスレッドを停止する必要があります: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_libusb_exit(<span
class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    event_thread_run = 0;</div>
<div class="line">    <a class="code"
href="group__libusb__hotplug.html#ga8110f57eab2064375934f1449b2602bc">libusb_hotplug_deregister_callback</a>(ctx,
hotplug_cb_handle); <span class="comment">// This wakes up
libusb_handle_events()</span></div>
<div class="line">    pthread_join(event_thread);</div>
<div class="line">    <a class="code"
href="group__libusb__lib.html#gadc174de608932caeb2fc15d94fa0844d">libusb_exit</a>(ctx);</div>
<div class="line">}</div>
</div> <!-- fragment -->
<h2 class="groupheader">Typedef解説</h2>
<a id="gac74874519794cd7aa40c0814702b0c88"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gac74874519794cd7aa40c0814702b0c88">&#9670;&nbsp;</a></span>libusb_transfer_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * libusb_transfer_cb_fn) (struct <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a> *transfer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>非同期転送コールバック関数型。非同期転送を送信するときは、 <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a> 構造体の <a class="el"
href="structlibusb__transfer.html#a69c6df011ec23ff3e481cc98bfff0623">callback</a>
メンバーを介してこのタイプのコールバック関数へのポインタを渡します。 libusbは、転送が完了または失敗したときに、後でこの関数を呼び出します。
詳細については、 <a class="el" href="group__libusb__asyncio.html">非同期デバイス入出力</a>
を参照してください。 </p><dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>The <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
構造体は、コールバック関数に通知されます。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">列挙型解説</h2>
<a id="gacb52027036a07de6ecc6c2bf07d07c71"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gacb52027036a07de6ecc6c2bf07d07c71">&#9670;&nbsp;</a></span>libusb_transfer_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el"
href="group__libusb__asyncio.html#gacb52027036a07de6ecc6c2bf07d07c71">libusb_transfer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>転送タイプ </p>
<table class="fieldtable">
<tr><th colspan="2">列挙型</th></tr><tr><td class="fieldname"><a
id="ggacb52027036a07de6ecc6c2bf07d07c71a4c89624658c783ef9b2a2f08091bc7d7"></a>LIBUSB_TRANSFER_TYPE_CONTROL&#160;</td><td class="fielddoc"><p>制御転送。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="ggacb52027036a07de6ecc6c2bf07d07c71a40de9889554fc1785d784b3c31333300"></a>LIBUSB_TRANSFER_TYPE_ISOCHRONOUS&#160;</td><td class="fielddoc"><p>アイソクロナス転送。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="ggacb52027036a07de6ecc6c2bf07d07c71a7bdfa2fc5dadbaaa0e9262e1b4a228e2"></a>LIBUSB_TRANSFER_TYPE_BULK&#160;</td><td class="fielddoc"><p>バルク転送。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="ggacb52027036a07de6ecc6c2bf07d07c71aefb0e07862c0eed894ec9c2f957a7e3c"></a>LIBUSB_TRANSFER_TYPE_INTERRUPT&#160;</td><td class="fielddoc"><p>割り込み転送。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="ggacb52027036a07de6ecc6c2bf07d07c71a3b26ee40f9c586ece75f8de822d974e3"></a>LIBUSB_TRANSFER_TYPE_BULK_STREAM&#160;</td><td class="fielddoc"><p>バルク・ストリーム転送 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9fcb2aa23d342060ebda1d0cf7478856"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga9fcb2aa23d342060ebda1d0cf7478856">&#9670;&nbsp;</a></span>libusb_transfer_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el"
href="group__libusb__asyncio.html#ga9fcb2aa23d342060ebda1d0cf7478856">libusb_transfer_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>転送ステータス・コード </p>
<table class="fieldtable">
<tr><th colspan="2">列挙型</th></tr><tr><td class="fieldname"><a
id="gga9fcb2aa23d342060ebda1d0cf7478856a4595f6532aab12352a58a0fd4ce48363"></a>LIBUSB_TRANSFER_COMPLETED&#160;</td><td class="fielddoc"><p>エラー無しで転送が完了した。 </p>
<p>注意: これは、要求されたデータの全量が転送されたことを示すものではないことに注意してください。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga9fcb2aa23d342060ebda1d0cf7478856aa8852ed719d03c2a3cc6f0312d919398"></a>LIBUSB_TRANSFER_ERROR&#160;</td><td class="fielddoc"><p>転送が失敗した。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga9fcb2aa23d342060ebda1d0cf7478856ac2b7626d7b51cb980f83933b6ada1ddf"></a>LIBUSB_TRANSFER_TIMED_OUT&#160;</td><td class="fielddoc"><p>転送タイムアウト。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga9fcb2aa23d342060ebda1d0cf7478856a8af1f19e46cccafdcf3feadce47e880b"></a>LIBUSB_TRANSFER_CANCELLED&#160;</td><td class="fielddoc"><p>転送がキャンセルされた。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga9fcb2aa23d342060ebda1d0cf7478856a23cdfd929f5fe82cca9654f8075eeebb"></a>LIBUSB_TRANSFER_STALL&#160;</td><td class="fielddoc"><p>バルク/割り込みエンドポイントの場合: 停止(halt)状態が検出されました(エンドポイントがストール(stall)しました)。 </p>
<p>制御エンドポイントの場合: その制御要求はサポートされていません。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga9fcb2aa23d342060ebda1d0cf7478856ab7dcb24f313ace407e0c070d6b2c5f13"></a>LIBUSB_TRANSFER_NO_DEVICE&#160;</td><td class="fielddoc"><p>デバイスが切断された。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga9fcb2aa23d342060ebda1d0cf7478856ab1b9cbcb1de27a8fbeceb3427fb2fb14"></a>LIBUSB_TRANSFER_OVERFLOW&#160;</td><td class="fielddoc"><p>デバイスが要求よりも多いデータを送信した。 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1fb47dd0f7c209b60a3609ff0c03d56d"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga1fb47dd0f7c209b60a3609ff0c03d56d">&#9670;&nbsp;</a></span>libusb_transfer_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el"
href="group__libusb__asyncio.html#ga1fb47dd0f7c209b60a3609ff0c03d56d">libusb_transfer_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el"
href="structlibusb__transfer.html#ae26c063df30c2e29835212aad98c6e06"
title="libusb_transfer_flagsのビットORの組み合わせ">libusb_transfer.flags</a> values </p>
<table class="fieldtable">
<tr><th colspan="2">列挙型</th></tr><tr><td class="fieldname"><a
id="gga1fb47dd0f7c209b60a3609ff0c03d56dae4c0697c266819c51c1734b3456e7276"></a>LIBUSB_TRANSFER_SHORT_NOT_OK&#160;</td><td class="fielddoc"><p>短いフレームをエラーとして報告します。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86"></a>LIBUSB_TRANSFER_FREE_BUFFER&#160;</td><td class="fielddoc"><p><a class="el"
href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6">libusb_free_transfer()</a>
中に転送バッファを自動的に free() します。 </p>
<p>注意: <a class="el"
href="group__libusb__asyncio.html#ga47c492e750197f1a28874c7a0dee40e3">libusb_dev_mem_alloc()</a>
で割り当てたバッファは、この方法で解放しようとしないでください。 free() はそのようなメモリを解放する適切な方法ではないためです。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga1fb47dd0f7c209b60a3609ff0c03d56dacf3f064997b283a14097c9f4d6f8ccc1"></a>LIBUSB_TRANSFER_FREE_TRANSFER&#160;</td><td class="fielddoc"><p>コールバックから戻った後、 <a class="el"
href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6">libusb_free_transfer()</a>
を自動的に呼び出します。 </p>
<p>このフラグが設定されている場合、転送のコールバックから <a class="el"
href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6">libusb_free_transfer()</a>
を呼び出すことは違法です。これは、このフラグが実行されたときに二重開放になるためです。 </p>
</td></tr>
<tr><td class="fieldname"><a
id="gga1fb47dd0f7c209b60a3609ff0c03d56da26b66334b6ec0537c49841ca623d901f"></a>LIBUSB_TRANSFER_ADD_ZERO_PACKET&#160;</td><td class="fielddoc"><p>エンドポイントのwMaxPacketSizeの倍数である転送を、長さがゼロの余分なパケットで終了します。 </p>
<p>これは、デバイスのプロトコルが、各論理要求を不完全なパケットで終了することを要求している場合に役立ちます(つまり、論理要求が他の手段で分離されていない場合)。</p>
<p>このフラグは、バルク・エンドポイントと割り込みエンドポイントの、ホストからデバイスへの方向の転送にのみ影響します。 他の状況では、これは無視されます。</p>
<p>このフラグは、エンドポイントのwMaxPacketSizeの倍数である長さの転送にのみ影響します。 他の長さの転送では、このフラグは効果がありません。
したがって、論理要求の終わりがパケット境界に達するたびにZLPを必要とするデバイスを使用している場合は、<em>全ての</em>転送でこのフラグを設定するのが賢明です(境界で終了する転送にのみ設定する事を考慮する必要はありません)。</p>
<p>このフラグは現在、Linuxでのみサポートされています。 他のシステムでは、 <a class="el"
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer()</a>
は、このフラグが設定されているすべての転送に対してLIBUSB_ERROR_NOT_SUPPORTEDを返します。</p>
<p>libusb-1.0.9以降で使用できます。 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">関数解説</h2>
<a id="gad7e786c1bedd4a668887564465101981"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gad7e786c1bedd4a668887564465101981">&#9670;&nbsp;</a></span>libusb_alloc_streams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_alloc_streams </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>指定のエンドポイントにnum_streams個のUSBバルク・ストリームを割り当てます。一部のプロトコルではエンドポイントを同じストリームIDでセットアップする必要があるため、この関数は単一のエンドポイントではなくエンドポイントの配列を取ります。渡されるすべてのエンドポイントは、同じインターフェースに属している必要があります。</p>
<p>注意: この関数は、要求よりも少ない数のストリームを返す可能性があることに注意してください。
また、エンドポイント配列の各エンドポイントにそれぞれ同じ数のストリームが割り当てられることに注意してください。</p>
<p>ストリームID 0 は予約済のため、デバイスとの通信には使用しないでください。 <a class="el"
href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981">libusb_alloc_streams()</a>
が値Nを返した場合、ストリームID 1〜N を使用できます。</p>
<p>バージョン1.0.19以降。 <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000103</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>デバイス・ハンドル </td></tr>
    <tr><td class="paramname">num_streams</td><td>割り当てを試みるストリームの数 </td></tr>
    <tr><td class="paramname">endpoints</td><td>ストリームを割り当てるエンドポイントの配列 </td></tr>
    <tr><td class="paramname">num_endpoints</td><td>エンドポイント配列のサイズ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>割り当てられたストリームの数、また、失敗した場合はLIBUSB_ERRORコード </dd></dl>

</div>
</div>
<a id="gab068de0fd203ccef5c620a8143526acb"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gab068de0fd203ccef5c620a8143526acb">&#9670;&nbsp;</a></span>libusb_free_streams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_free_streams </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el"
href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981">libusb_alloc_streams()</a>
で割り当てられたUSBバルク・ストリームを解放します。</p>
<p>注意: インターフェイスを解放すると、ストリームは自動的に解放されます。</p>
<p>バージョン1.0.19以降。 <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000103</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>デバイス・ハンドル </td></tr>
    <tr><td class="paramname">endpoints</td><td>ストリームを開放したいエンドポイントの配列 </td></tr>
    <tr><td class="paramname">num_endpoints</td><td>エンドポイント配列のサイズ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>LIBUSB_SUCCESS、または、失敗の場合はLIBUSB_ERRORコード </dd></dl>

</div>
</div>
<a id="ga47c492e750197f1a28874c7a0dee40e3"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga47c492e750197f1a28874c7a0dee40e3">&#9670;&nbsp;</a></span>libusb_dev_mem_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* libusb_dev_mem_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>特定のデバイスに対する転送に適した永続的なDMAメモリのブロックを割り当てようとします。 成功すると、このデバイスに対する <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a> の "バッファ"
として使用するのに適したメモリ・ブロックが返されます。通常のメモリの代わりにこのメモリを使用すると、ホスト・コントローラはDMAを直接バッファに使用してパフォーマンスを向上させることができ、カーネル・メモリの断片化が原因で転送が失敗することもなくなります。</p>
<p>注意:これは、転送の進行中にこのメモリ(または同じキャッシュ・ライン上のデータ)を変更してはならないことを意味しますが、同じメモリブロック内で複数の転送を実行することは合法です。</p>
<p>失敗するとNULLを返します。多くのシステムはそのようなゼロ・コピーをサポートしておらず、常にNULLを返します。この関数で割り当てられたメモリは、
<a class="el"
href="group__libusb__asyncio.html#gad7575ff325f0159a5b74b7c0ee64eb62">libusb_dev_mem_free</a>
で解放する必要があります。
具体的には、これは、フラグLIBUSB_TRANSFER_FREE_BUFFERを使用して、この関数で割り当てられたメモリを解放できないことを意味します。</p>
<p>Since version 1.0.21, <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000105</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>デバイス・ハンドル </td></tr>
    <tr><td class="paramname">length</td><td>必要なデータ・バッファのサイズ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>新しく割り当てられたメモリへのポインタ、または失敗した場合はNULL </dd></dl>

</div>
</div>
<a id="gad7575ff325f0159a5b74b7c0ee64eb62"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gad7575ff325f0159a5b74b7c0ee64eb62">&#9670;&nbsp;</a></span>libusb_dev_mem_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_dev_mem_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el"
href="group__libusb__asyncio.html#ga47c492e750197f1a28874c7a0dee40e3">libusb_dev_mem_alloc()</a>
で割り当てられたデバイス・メモリを解放します。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>デバイス・ハンドル </td></tr>
    <tr><td class="paramname">buffer</td><td>以前に割り当てられたメモリへのポインタ </td></tr>
    <tr><td class="paramname">length</td><td>以前に割り当てられたメモリのサイズ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>LIBUSB_SUCCESS、または、失敗の場合はLIBUSB_ERRORコード </dd></dl>

</div>
</div>
<a id="ga13cc69ea40c702181c430c950121c000"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga13cc69ea40c702181c430c950121c000">&#9670;&nbsp;</a></span>libusb_alloc_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>*
libusb_alloc_transfer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iso_packets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>指定された数のアイソクロナス・パケット・デスクリプターを使用してlibusb転送を割り当てます。返される転送は事前に初期化されています。最早新しい転送が不要になったら、
<a class="el"
href="group__libusb__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6">libusb_free_transfer()</a>
で解放する必要があります。</p>
<p>非アイソクロナス・エンドポイント(制御、バルク、割り込みなど)を対象とした転送では、iso_packetsカウントをゼロに指定すべきです。</p>
<p>アイソクロナス・エンドポイントを対象とした転送の場合、その転送の一部として割り当てられる適切な数のパケット・デスクリプターを指定します。
その戻される転送は、アイソクロナス入出力用に特別に初期化されてはいません。それでも、それに応じて <a class="el"
href="structlibusb__transfer.html#a87d725a5521c26832fdc13611220014d">num_iso_packets</a>
フィールドと <a class="el"
href="structlibusb__transfer.html#a7c9fa575986fe9f23bbecb26b766dff1">type</a>
フィールドを設定する必要があります。</p>
<p>いくつかのアイソクロナス・パケットを使用して転送を割り当て、それを非アイソクロナス・エンドポイントで使用するのが安全です。これを行う場合は、送信時にnum_iso_packetsが0であり、そのtypeが適切に設定されていることを確認してください。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">iso_packets</td><td>割り当てるアイソクロナス・パケット・デスクリプターの数。負でない数値である必要があります。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>新しく割り当てられた転送、またはエラーの場合はNULL </dd></dl>

</div>
</div>
<a id="ga6ab8b2cff4de9091298a06b2f4b86cd6"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga6ab8b2cff4de9091298a06b2f4b86cd6">&#9670;&nbsp;</a></span>libusb_free_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_free_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>転送構造体を解放します。これは、 <a class="el"
href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer()</a>
で割り当てられたすべての転送に対して呼び出す必要があります。</p>
<p><a class="el"
href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86">LIBUSB_TRANSFER_FREE_BUFFER</a>
フラグが設定されていて、そして転送バッファーがNULL以外の場合、この関数は標準のシステム・メモリ割り当て機構(例: free()
)を使用して転送バッファーも解放します。</p>
<p>NULL転送でこの関数を呼び出すことは合法です。この場合、関数は単に安全に戻ります。</p>
<p>アクティブな転送(送信(submit)され、まだ完了していない転送)を解放することは違法です。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>開放したい転送 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb0932601f2c7dad2fee4b27962848ce"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gabb0932601f2c7dad2fee4b27962848ce">&#9670;&nbsp;</a></span>libusb_submit_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_submit_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>転送を送信します。この関数は、USB転送を開始し、すぐに戻ります。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>送信する転送 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば成功 </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE: デバイスが切断されていた </dd>
<dd>
LIBUSB_ERROR_BUSY: その転送がすでに送信されている(submitted)場合。 </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED: その転送フラグがオペレーティング・システムでサポートされていない場合。 </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM: 転送サイズがオペレーティング・システムやハードウェアでサポートできるサイズよりも大きい場合(<a
class="el" href="group__libusb__asyncio.html#asynclimits">転送の長さの制限</a> を参照)。 </dd>
<dd>
LIBUSB_ERRORコード: その他の障害 </dd></dl>

</div>
</div>
<a id="ga685eb7731f9a0593f75beb99727bbe54"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga685eb7731f9a0593f75beb99727bbe54">&#9670;&nbsp;</a></span>libusb_cancel_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_cancel_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>以前に送信された転送を非同期的にキャンセルします。この関数はすぐに戻りますが、それはキャンセルが完了したことを示すものではありません。後で、転送ステータスLIBUSB_TRANSFER_CANCELLEDでコールバック関数が呼び出されます。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>キャンセルしたい転送 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば成功 </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND 転送が現在進行中でないか、または既に完了したか、または既にキャンセルされた場合。 </dd>
<dd>
LIBUSB_ERRORコード: 失敗の場合。 </dd></dl>

</div>
</div>
<a id="gaeae2db23b9de811af317483afdeb230f"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gaeae2db23b9de811af317483afdeb230f">&#9670;&nbsp;</a></span>libusb_transfer_set_stream_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_transfer_set_stream_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stream_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>転送バルク・ストリームIDを設定します。この関数を直接呼び出すのではなく、 <a class="el"
href="group__libusb__asyncio.html#gac2e84d8fb9218d3c67e6a4fd4ade5b10">libusb_fill_bulk_stream_transfer()</a>
を使用することをお勧めします。</p>
<p>バージョン1.0.19以降。 <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000103</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>ストリームIDをセットしたい転送 </td></tr>
    <tr><td class="paramname">stream_id</td><td>セットしたいストリームID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>これも参照下さい</dt><dd><a class="el"
href="group__libusb__asyncio.html#gad7e786c1bedd4a668887564465101981">libusb_alloc_streams()</a> </dd></dl>

</div>
</div>
<a id="ga631653487273f3306925131cdc0a3ffc"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga631653487273f3306925131cdc0a3ffc">&#9670;&nbsp;</a></span>libusb_transfer_get_stream_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t libusb_transfer_get_stream_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>転送バルク・ストリームIDを取得します。</p>
<p>バージョン1.0.19以降。 <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000103</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>ストリームIDを取得したい転送 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>その転送のストリームID </dd></dl>

</div>
</div>
<a id="gadf9c633586dde54ce62a3d66a4d7554c"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gadf9c633586dde54ce62a3d66a4d7554c">&#9670;&nbsp;</a></span>libusb_control_transfer_get_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char* libusb_control_transfer_get_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>制御転送のデータ・セクションを取得します。この便利な関数は、セットアップ・パケットが最初に来るため、実際のバッファに8バイト入るまでデータが開始されないことを思い出させるためにここにあります。</p>
<p>この関数の呼び出しは、転送コールバック関数、または transfer-＆gt; buffer
で適切なサイズのバッファをすでに割り当てている状況からのみ意味があります。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>とある一つの転送 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>データ・セクションの最初のバイトへのポインタ </dd></dl>

</div>
</div>
<a id="ga6ab02f15e11b5b03b1174fbd7c3bc061"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga6ab02f15e11b5b03b1174fbd7c3bc061">&#9670;&nbsp;</a></span>libusb_control_transfer_get_setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el"
href="structlibusb__control__setup.html">libusb_control_setup</a>*
libusb_control_transfer_get_setup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>制御転送の制御セットアップ・パケットを取得します。
この便利な関数は、制御セットアップが転送データ・バッファの最初の8バイトを占めることを思い出させるためにここにあります。</p>
<p>この関数の呼び出しは、転送コールバック関数、または transfer-＆gt; buffer
で適切なサイズのバッファをすでに割り当てている状況からのみ意味があります。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>とある一つの転送 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>転送データバッファの開始へのキャストされたポインタ </dd></dl>

</div>
</div>
<a id="ga5447311149ec2bd954b5f1a640a8e231"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga5447311149ec2bd954b5f1a640a8e231">&#9670;&nbsp;</a></span>libusb_fill_control_setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_control_setup </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>制御転送用のセットアップ・パケット(データ・バッファの最初の8バイト)を設定するヘルパー関数。
wIndexとwValueとwLengthの値は、ホスト・エンディアンのバイト順序で指定する必要があります。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>セットアップ・パケットを出力するバッファこのポインタは、少なくとも2バイト境界に揃える必要があります。 </td></tr>
    <tr><td class="paramname">bmRequestType</td><td><a class="el"
href="structlibusb__control__setup.html">libusb_control_setup</a> の <a
class="el"
href="structlibusb__control__setup.html#a39b148c231d675492ccd2383196926bf">bmRequestType</a>
フィールドを参照してください </td></tr>
    <tr><td class="paramname">bRequest</td><td><a class="el"
href="structlibusb__control__setup.html">libusb_control_setup</a> の <a
class="el"
href="structlibusb__control__setup.html#a1b80a28b8d4e8586fc54358194e70087">bRequest</a>
フィールドを参照して下さい </td></tr>
    <tr><td class="paramname">wValue</td><td><a class="el"
href="structlibusb__control__setup.html">libusb_control_setup</a> の <a
class="el"
href="structlibusb__control__setup.html#abbb6daa01fe4b6a05dc43492e4e53a7d">wValue</a>
フィールドを参照して下さい </td></tr>
    <tr><td class="paramname">wIndex</td><td><a class="el"
href="structlibusb__control__setup.html">libusb_control_setup</a> の <a
class="el"
href="structlibusb__control__setup.html#a70c2ae456344b200a19d434ace85ae2b">wIndex</a>
フィールドを参照して下さい </td></tr>
    <tr><td class="paramname">wLength</td><td><a class="el"
href="structlibusb__control__setup.html">libusb_control_setup</a> の <a
class="el"
href="structlibusb__control__setup.html#a3c442c64fd7619b43b782367235766cc">wLength</a>
フィールドを参照して下さい </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a8513ed87229fe2c9771ef0bf17206e"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga3a8513ed87229fe2c9771ef0bf17206e">&#9670;&nbsp;</a></span>libusb_fill_control_transfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_control_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>制御転送に必要な <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a> フィールドに情報を入力するヘルパー関数。</p>
<p>この関数に転送バッファーを渡すと、最初の8バイトが制御セットアップ・パケットとして解釈され、wLengthフィールドを使用して転送の <a
class="el"
href="structlibusb__transfer.html#a68c023e1f40b50aa8604a2495b6a391e">length</a>
フィールドに自動的に入力されます。したがって、推奨されるアプローチは以下のとおりです:</p><ol type="1">
<li>(制御セットアップ用のスペースを含む)適切なサイズのデータ・バッファを割り当てます</li>
<li><a class="el"
href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup()</a>
を呼び出します</li>
<li>これがデータ・ステージを使用したホストからデバイスへの転送である場合は、セットアップ・パケットの後ろにデータを配置します</li>
<li>この関数を呼び出します</li>
<li><a class="el"
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer()</a>
を呼び出します。</li>
</ol>
<p>この関数にNULLバッファーを渡すことも合法です。この場合、この関数はlengthフィールドにデータを入力しようとしません。
後でバッファ・フィールドとlengthフィールドにデータを入力する必要があることに注意してください。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>入力対象の転送 </td></tr>
    <tr><td class="paramname">dev_handle</td><td>転送を処理するデバイスのハンドル </td></tr>
    <tr><td class="paramname">buffer</td><td>データ・バッファ。
指定されている場合、この関数は最初の8バイトをセットアップ・パケットとして解釈し、そこから転送長を推測します。このポインタは、少なくとも2バイト境界に揃える必要があります。 </td></tr>
    <tr><td class="paramname">callback</td><td>転送完了時に呼び出されるコールバック関数 </td></tr>
    <tr><td class="paramname">user_data</td><td>コールバック関数に渡すユーザー・データ </td></tr>
    <tr><td class="paramname">timeout</td><td>転送のタイムアウト(ミリ秒単位) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4ddb1a5c6c7fefc979a44d7300b95d7"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gad4ddb1a5c6c7fefc979a44d7300b95d7">&#9670;&nbsp;</a></span>libusb_fill_bulk_transfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_bulk_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>バルク転送に必要な <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a>
のフィールド群にデータを入力するヘルパー関数。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>入力対象の転送 </td></tr>
    <tr><td class="paramname">dev_handle</td><td>転送を処理するデバイスのハンドル </td></tr>
    <tr><td class="paramname">endpoint</td><td>この転送を送るエンドポイントのアドレス </td></tr>
    <tr><td class="paramname">buffer</td><td>データ・バッファ </td></tr>
    <tr><td class="paramname">length</td><td>データ・バッファの長さ </td></tr>
    <tr><td class="paramname">callback</td><td>転送完了時に呼び出されるコールバック関数 </td></tr>
    <tr><td class="paramname">user_data</td><td>コールバック関数に渡すユーザー・データ </td></tr>
    <tr><td class="paramname">timeout</td><td>転送のタイムアウト(ミリ秒単位) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac2e84d8fb9218d3c67e6a4fd4ade5b10"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gac2e84d8fb9218d3c67e6a4fd4ade5b10">&#9670;&nbsp;</a></span>libusb_fill_bulk_stream_transfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_bulk_stream_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stream_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>バルク・ストリームを使用したバルク転送に必要な <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a>
のフィールド群にデータを入力するヘルパー関数。</p>
<p>バージョン1.0.19以降。 <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000103</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>入力対象の転送 </td></tr>
    <tr><td class="paramname">dev_handle</td><td>転送を処理するデバイスのハンドル </td></tr>
    <tr><td class="paramname">endpoint</td><td>この転送を送るエンドポイントのアドレス </td></tr>
    <tr><td class="paramname">stream_id</td><td>この転送のバルク・ストリームID </td></tr>
    <tr><td class="paramname">buffer</td><td>データ・バッファ </td></tr>
    <tr><td class="paramname">length</td><td>データ・バッファの長さ </td></tr>
    <tr><td class="paramname">callback</td><td>転送完了時に呼び出されるコールバック関数 </td></tr>
    <tr><td class="paramname">user_data</td><td>コールバック関数に渡すユーザー・データ </td></tr>
    <tr><td class="paramname">timeout</td><td>転送のタイムアウト(ミリ秒単位) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90f53cea1124a7566df1aa1202b77510"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga90f53cea1124a7566df1aa1202b77510">&#9670;&nbsp;</a></span>libusb_fill_interrupt_transfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_interrupt_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>割り込み転送に必要な <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a>
のフィールド群にデータを入力するヘルパー関数。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>入力対象の転送 </td></tr>
    <tr><td class="paramname">dev_handle</td><td>転送を処理するデバイスのハンドル </td></tr>
    <tr><td class="paramname">endpoint</td><td>この転送を送るエンドポイントのアドレス </td></tr>
    <tr><td class="paramname">buffer</td><td>データ・バッファ </td></tr>
    <tr><td class="paramname">length</td><td>データ・バッファの長さ </td></tr>
    <tr><td class="paramname">callback</td><td>転送完了時に呼び出されるコールバック関数 </td></tr>
    <tr><td class="paramname">user_data</td><td>コールバック関数に渡すユーザー・データ </td></tr>
    <tr><td class="paramname">timeout</td><td>転送のタイムアウト(ミリ秒単位) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30fdce8c461e851f0aa4c851014e1aa7"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga30fdce8c461e851f0aa4c851014e1aa7">&#9670;&nbsp;</a></span>libusb_fill_iso_transfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_fill_iso_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>
*&#160;</td>
          <td class="paramname"><em>dev_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iso_packets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__asyncio.html#gac74874519794cd7aa40c0814702b0c88">libusb_transfer_cb_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>アイソクロナス転送に必要な <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a>
のフィールド群にデータを入力するヘルパー関数。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>入力対象の転送 </td></tr>
    <tr><td class="paramname">dev_handle</td><td>転送を処理するデバイスのハンドル </td></tr>
    <tr><td class="paramname">endpoint</td><td>この転送を送るエンドポイントのアドレス </td></tr>
    <tr><td class="paramname">buffer</td><td>データ・バッファ </td></tr>
    <tr><td class="paramname">length</td><td>データ・バッファの長さ </td></tr>
    <tr><td class="paramname">num_iso_packets</td><td>アイソクロナス・パケットの数 </td></tr>
    <tr><td class="paramname">callback</td><td>転送完了時に呼び出されるコールバック関数 </td></tr>
    <tr><td class="paramname">user_data</td><td>コールバック関数に渡すユーザー・データ </td></tr>
    <tr><td class="paramname">timeout</td><td>転送のタイムアウト(ミリ秒単位) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbdecd6f50093f0c1d0e72ee35ace274"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gacbdecd6f50093f0c1d0e72ee35ace274">&#9670;&nbsp;</a></span>libusb_set_iso_packet_lengths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void libusb_set_iso_packet_lengths </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>転送構造構造体のnum_iso_packetsフィールドに基づいて、アイソクロナス転送でのすべてのパケットの長さを設定する便利な関数。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>とある一つの転送 </td></tr>
    <tr><td class="paramname">length</td><td>各アイソクロナス・パケット・デスクリプターに設定する長さ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>これも参照下さい</dt><dd><a class="el"
href="group__libusb__dev.html#gac81968047e262409e78f3fe24321b604">libusb_get_max_packet_size()</a> </dd></dl>

</div>
</div>
<a id="ga7f6ea0eb35a216d19d984977e454a7b3"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga7f6ea0eb35a216d19d984977e454a7b3">&#9670;&nbsp;</a></span>libusb_get_iso_packet_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char* libusb_get_iso_packet_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>アイソクロナス転送のバッファ内でアイソクロナス・パケットの位置を特定するための便利な関数。</p>
<p>これは、先行するすべてのパケットに対して繰り返し作業を行い、それらの長さを足しこんで指定されたパケットの位置を見つける完全な関数です。通常、転送では各パケットに同じ長さを割り当てるため、この方法は最適とは言えません。代わりに
<a class="el"
href="group__libusb__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd">libusb_get_iso_packet_buffer_simple()</a>
を使用することをお勧めします。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>とある一つの転送 </td></tr>
    <tr><td class="paramname">packet</td><td>アドレスを知りたいパケット(訳注:パケットNo. 0〜) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>転送バッファ内のパケット・バッファのベース・アドレス。パケットが存在しない場合はNULL。 </dd></dl>
<dl class="section see"><dt>これも参照下さい</dt><dd><a class="el"
href="group__libusb__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd">libusb_get_iso_packet_buffer_simple()</a> </dd></dl>

</div>
</div>
<a id="ga3df9a28c4f5c8f1850181ddb5efd12fd"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga3df9a28c4f5c8f1850181ddb5efd12fd">&#9670;&nbsp;</a></span>libusb_get_iso_packet_buffer_simple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char* libusb_get_iso_packet_buffer_simple </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
*&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span
class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>各パケットが同じサイズの転送の場合、アイソクロナス転送のバッファ内でアイソクロナス・パケットの位置を特定するための便利な関数。</p>
<p>この関数は、その転送内のすべてのパケットが最初のパケットと同じサイズであるという仮定に依存しています。パケット・バッファの位置の計算は
<code>buffer + (packet_size * packet)</code> という単純な計算です。</p>
<p>各パケットのパケット長が同じである転送以外の転送では、この関数を使用しないでください。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">transfer</td><td>とある一つの転送 </td></tr>
    <tr><td class="paramname">packet</td><td>アドレスを知りたいパケット(訳注:パケットNo. 0〜) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>転送バッファ内のパケット・バッファのベース・アドレス。パケットが存在しない場合はNULL。 </dd></dl>
<dl class="section see"><dt>これも参照下さい</dt><dd><a class="el"
href="group__libusb__asyncio.html#ga7f6ea0eb35a216d19d984977e454a7b3">libusb_get_iso_packet_buffer()</a> </dd></dl>

</div>
</div>
</div>
<!-- contents -->
<div class="ttc" id="agroup__libusb__poll_html_ga4989086e3f0327f3886a4c474ec7c327"><div class="ttname"><a
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events</a></div><div class="ttdeci">int libusb_handle_events(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:2407</div></div>
<div class="ttc" id="agroup__libusb__lib_html_gadc174de608932caeb2fc15d94fa0844d"><div class="ttname"><a
href="group__libusb__lib.html#gadc174de608932caeb2fc15d94fa0844d">libusb_exit</a></div><div class="ttdeci">void libusb_exit(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> core.c:2385</div></div>
<div class="ttc" id="astructlibusb__transfer_html_adaaf06aeb5ab2a8819e75310ec253f7a"><div class="ttname"><a
href="structlibusb__transfer.html#adaaf06aeb5ab2a8819e75310ec253f7a">libusb_transfer::dev_handle</a></div><div class="ttdeci">libusb_device_handle * dev_handle</div><div class="ttdoc">この転送が送信されるデバイスのハンドル。</div><div class="ttdef"><b>定義:</b> libusb.h:1224</div></div>
<div class="ttc" id="agroup__libusb__hotplug_html_ga8110f57eab2064375934f1449b2602bc"><div class="ttname"><a
href="group__libusb__hotplug.html#ga8110f57eab2064375934f1449b2602bc">libusb_hotplug_deregister_callback</a></div><div class="ttdeci">void libusb_hotplug_deregister_callback(libusb_context *ctx,
libusb_hotplug_callback_handle callback_handle)</div><div class="ttdef"><b>定義:</b> hotplug.c:404</div></div>
<div class="ttc" id="agroup__libusb__dev_html_ga779bc4f1316bdb0ac383bddbd538620e"><div class="ttname"><a
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close</a></div><div class="ttdeci">void libusb_close(libusb_device_handle *dev_handle)</div><div class="ttdef"><b>定義:</b> core.c:1446</div></div>
<div class="ttc" id="agroup__libusb__dev_html_ga7df95821d20d27b5597f1d783749d6a4"><div class="ttname"><a
href="group__libusb__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a></div><div class="ttdeci">struct libusb_device_handle libusb_device_handle</div><div class="ttdef"><b>定義:</b> libusb.h:1015</div></div>

<!-- start footer part -->
<hr class="footer"/><address class="footer"><small> Generated on Fri Jul 9 2021 02:35:39 for libusb by &#160;<a
href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17 </small></address>
</body>
</html>
