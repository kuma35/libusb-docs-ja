<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libusb: 警告</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libusb &#160;<span id="projectnumber">1.0.24</span>
   </div>
   <div id="projectbrief">USBデバイスにアクセスするためのクロス・プラットフォームのユーザー・ライブラリ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>


<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license
magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt
GPL-v2 */ $(function() { initMenu('',false,false,'search.php','Search'); });
/* @license-end */</script>
<div id="main-nav"></div>
</div>
<!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">警告 </div>  </div>
</div>
<!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="threadsafety"></a>スレッド・セーフ</h1>
<p>libusbは完全にスレッド・セーフになるように設計されていますが、他のAPIと同様に、意図的であろうとなかろうと、ユーザーが自分自身で妨害するのを防ぐことはできません。</p>
<p>以下の一般的なガイドラインに従ってください:</p>
<ul>
<li>リソースを解放する関数(<a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>、
<a class="el"
href="group__libusb__desc.html#ga18d2b08a065857ff7ae4f3f719c115cc">libusb_free_config_descriptor()</a>など)の呼び出しは、同じリソースで同時に呼び出さないでください。
これは、割り当てられたポインタに複数の free() を呼び出すのと同じです。</li>
<li>個々の <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
は、単一のスレッドで準備する必要があります。 つまり、 <a class="el"
href="structlibusb__transfer.html">libusb_transfer</a>
のフィールドに2つのスレッドが同時に入力することはできません。 これは、複数のスレッドから同じ宛先バッファーを使用して sprintf()
を呼び出すことに例えることができます。
入力パラメーターがすべて同じでない限り、結果は希望どおりにならない可能性があります。しかし、そもそも、この状況を完全に回避するのがいちばん良い方法です。</li>
<li><a class="el" href="structlibusb__transfer.html">libusb_transfer</a>
構造体とそれに関連するデータ・バッファの両方に、転送が送信されてから完了コールバックが呼び出されるまでの間はアクセスしないでください。これら構造体やデータ・バッファの
"所有権" も、転送がアクティブな間はlibusbに転送されていると考えることができます。</li>
<li>さまざまな "セッター"(setter) 関数(<a class="el"
href="group__libusb__lib.html#ga2efb66b8f16ffb0851f3907794c06e20">libusb_set_log_cb()</a>、
<a class="el"
href="group__libusb__poll.html#ga1b7b2deb193f2e9ffda5e727361d7e67">libusb_set_pollfd_notifiers()</a>
など)をそのリソースで同時に呼び出すことはできません。そうすることで未定義の動作が発生することはありませんが、アプリケーションで予期しない結果が生じる可能性があります。</li>
</ul>
<p>複数のスレッドと非同期入出力のルールについては、<a
class="el"href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a>
で詳しく説明しています。</p>
<h1><a class="anchor" id="fork"></a> フォーク(fork)に関する考慮</h1>
<p>libusbは、fork() 呼び出しが全体で機能するように<em>設計されていません</em>。
プラットフォームによっては、子プロセスが利用できないリソースが親プロセスにある場合があります(Linuxの活線挿抜監視スレッドなど)。
さらに、親プロセスと子プロセスはlibusbの内部ファイル・デスクリプターを共有するため、子プロセスから何らかの方法でlibusbを使用すると、親プロセスの
<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
が不整合な状態になる可能性があります。</p>
<p>Linuxでは、libusbのファイル・デスクリプターはCLOEXECとしてマークされます。これは、子プロセスが状態をクリーン・アップする必要があることや、これらのファイル・デスクリプターにアクセスすることを心配せずに、
fork() および exec() を安全に実行できることを意味します。 他のプラットフォームはそれほど寛容ではないかもしれないので、各自ご注意下さい！</p>
<h1><a class="anchor" id="devresets"></a> デバイス・リセット</h1>
<p><a class="el"
href="group__libusb__dev.html#gafee9c4638f1713ca5faa867948878111">libusb_reset_device()</a>
関数を使用すると、デバイスをリセットできます。
プログラムがそのような関数を呼び出さなければならない場合、リセットによってデバイスの状態が変化することをちゃんと認識しておく必要があります(たとえば、レジスタ値がリセットされる可能性があります)。</p>
<p>問題は、他のプログラムが、そのプログラムが動作しているデバイスをいつでもリセットする可能性があることです。
libusbは、これが発生したときに通知するメカニズムを提供していないため、他の誰かがデバイスをリセットした場合、そのデバイスの状態が変更された理由は自分のプログラムでは明確ではありません。</p>
<p>つまり、これはユーザー空間でのドライバーの書き込みの制限です。基盤となるカーネルのUSBスタックから分離すると、オペレーティング・システムがそのような通知をプログラムに配信することが困難になります。LinuxカーネルのUSBスタックでは、このようなリセット通知をカーネル内のUSBドライバーに配信できますが、ユーザー空間に存在するセカンド・クラスのドライバーにこのような通知を配信する方法は明確にはありません。</p>
<h1><a class="anchor" id="blockonly"></a> ブロッキングのみの機能</h1>
<p>以下にリストされている機能は、同期のブロック機能を介してのみ使用できます。
非同期/非ブロッキングの代替手段はなく、これらを実装する明確な方法もありません。</p>
<ul>
<li>構成のアクティブ化(<a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>)</li>
<li>インターフェイス/代替設定 のアクティブ化(<a class="el"
href="group__libusb__dev.html#ga4858ad4f0f58fd1dc0afaead1fe6479a">libusb_set_interface_alt_setting()</a>)</li>
<li>インターフェイスの解放(<a class="el"
href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa">libusb_release_interface()</a>)</li>
<li>停止(halt)/失速(stall)状態のクリア(<a class="el"
href="group__libusb__dev.html#gab794bbc0b055d140f186f5a4d39c0891">libusb_clear_halt()</a>)</li>
<li>デバイス・リセット(<a class="el"
href="group__libusb__dev.html#gafee9c4638f1713ca5faa867948878111">libusb_reset_device()</a>)</li>
</ul>
<h1><a class="anchor" id="configsel"></a> 構成(configuration)の選択と処理</h1>
<p>libusbがデバイス・ハンドルをアプリケーションに提示すると、対応するデバイスが未構成の状態になる可能性があります。複数の構成を持つデバイスの場合、現在選択されている構成がアプリケーションで使用したい構成ではない可能性もあります。</p>
<p>明らかな解決策は、デバイスの初期化ルーチンの早い段階で <a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>
への呼び出しを追加することですが、以下の注意事項があります:</p><ol type="1">
<li>デバイスがすでに目的の構成である場合、同じ構成値を使用して <a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>
を呼び出すと、軽量デバイス(lightweight device)がリセットされます。これは望ましい動作ではない場合があります。</li>
<li>目的の構成がすでにアクティブになっている場合、libusbは軽量デバイスのリセットを実行することさえできない場合があります。たとえば、指紋リーダー付きのUSBキーボードを考えてみましょう。libusbを介して指紋リーダー・インターフェイスを駆動することに興味がありますが、カーネルのUSB-HIDドライバーはほとんどの場合キーボード・インターフェイスを要求します。カーネルがインターフェイスを要求しているため、軽量デバイス(lightweight
device)のリセットを実行することさえできず、 <a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>
は失敗します。 (幸いなことに、問題のデバイスはの1つの構成だけを持ちます。）</li>
<li>他のプログラムまたはドライバーがインターフェイスを要求している場合、libusbは構成を設定できません。 特に、これは、 <a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>
が成功する前に、カーネル・ドライバーをすべてのインターフェイスから切り離す必要があることを意味します。</li>
</ol>
<p>上記の問題のいくつかに対する1つの解決策は、現在アクティブな構成を調べることです。必要な構成がすでにアクティブになっている場合は、構成を選択する必要はありません: </p><div class="fragment"><div class="line">cfg = -1;</div>
<div class="line"><a class="code"
href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">libusb_get_configuration</a>(dev,
&amp;cfg);</div>
<div class="line"><span class="keywordflow">if</span> (cfg != desired)</div>
<div class="line">    <a class="code"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration</a>(dev,
desired);</div>
</div><!-- fragment -->
<p>これはおそらくほとんどのシナリオに適していますが、本質的に際どいものです。なぜなら、 <a class="el"
href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">libusb_get_configuration()</a>
の<em>呼び出し後</em>に、別のアプリケーションまたはドライバーが選択した構成を変更する場合があるからです。</p>
<p><a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>
が成功した場合でも、あなたのアプリケーションが <a class="el"
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>
を呼び出した後、他のアプリケーションまたはドライバーが構成を変更する可能性があることを考慮してください。</p>
<p>デバイスを特定の構成にロックする方法の一つは以下のとおりです:</p><ol type="1">
<li>目的の構成を設定します(または上記のロジックを使用して、既に目的の構成になっていることを確認します)</li>
<li>あなたが使用したいインターフェイスを要求する</li>
<li>現在アクティブな構成が、あなたが使用したい構成であることを確認してください。</li>
</ol>
<p>上記の方法が機能するのは、インターフェイスが要求されると、アプリケーションまたはドライバーは別の構成を選択できないためです。</p>
<h1><a class="anchor" id="earlycomp"></a> 転送の早期完了</h1>
<p>注意:
この節は現在Linuxを主眼に記述されています。これらの考慮事項のいずれがDarwinまたは他のプラットフォームに適用されるかどうかはわかりません。</p>
<p>転送が早期に完了すると(つまり、転送バッファーで許可されるよりも少ないデータが1つのパケットで送受信される場合)、libusbは転送をすぐに終了するように設計されており、他の転送がユーザーによってキューに入れられていない限り、それ以上データを転送または受信しません。</p>
<p>旧来のプラットフォームでは、libusbはすべての状況でこれを実行できるわけではありません。不完全なパケットが発生した後、"余剰"
データが転送される場合があります。
libusbの最近のバージョンでは、この情報が保持され(転送のデータ長が更新されます)、デバイスからホストへの転送では、余分なデータがバッファーに追加されました。それでも、これは短いパケットの終わりに関する情報を失うため、良い解決策ではありません。ユーザーは、余ったデータが次の論理転送で到着することを望んでいた可能性があります。</p>
<h1><a class="anchor" id="zlp"></a> 長さゼロのパケット</h1>
<ul>
<li>libusbでは長さゼロの転送を送信すれば、長さがゼロのパケットをエンドポイントに送信できます。</li>
<li>The <a class="el"
href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56da26b66334b6ec0537c49841ca623d901f">LIBUSB_TRANSFER_ADD_ZERO_PACKET</a>
フラグは現在、Linuxのみでサポートされます。 </li>
</ul>
</div></div>
<!-- contents -->
</div>
<!-- PageDoc -->
<div class="ttc" id="agroup__libusb__dev_html_ga785ddea63a2b9bcb879a614ca4867bed"><div class="ttname"><a
href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration</a></div><div class="ttdeci">int libusb_set_configuration(libusb_device_handle *dev_handle, int
configuration)</div><div class="ttdef"><b>定義:</b> core.c:1619</div></div>
<div class="ttc" id="agroup__libusb__dev_html_gae921014b888b105471a31d54c77c1c4d"><div class="ttname"><a
href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">libusb_get_configuration</a></div><div class="ttdeci">int libusb_get_configuration(libusb_device_handle *dev_handle, int *config)</div><div class="ttdef"><b>定義:</b> core.c:1533</div></div>

<!-- start footer part -->
<hr class="footer"/><address class="footer"><small> Generated on Fri Jul 9 2021 02:35:39 for libusb by &#160;<a
href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17 </small></address>
</body>
</html>
