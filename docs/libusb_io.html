<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libusb: 同期・非同期デバイス入出力</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libusb &#160;<span id="projectnumber">1.0.24</span>
   </div>
   <div id="projectbrief">USBデバイスにアクセスするためのクロス・プラットフォームのユーザー・ライブラリ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>


<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license
magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt
GPL-v2 */ $(function() { initMenu('',false,false,'search.php','Search'); });
/* @license-end */</script>
<div id="main-nav"></div>
</div>
<!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">同期・非同期デバイス入出力 </div>  </div>
</div>
<!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="io_intro"></a> はじめに</h1>
<p>アプリケーションでlibusbを使用している場合は、あなたはおそらくデバイスで入出力を実行したい、あなたはUSBデータ転送を実行したいと思うでしょう。</p>
<p>libusbは、デバイス入出力用に2つの別個のインターフェースを提供します。
このページは、どちらがアプリケーションに適しているかを判断するのに役立つように、その2つを紹介することを目的としています。ケース・バイ・ケースで各転送を検討することにより、アプリケーションで両方のインターフェイスの使用を選択することもできます。</p>
<p>以下の説明を読み終えたら、詳細については詳細なAPI文書を参照してください:</p><ul>
<li><a class="el" href="group__libusb__syncio.html">同期デバイス入出力</a></li>
<li><a class="el" href="group__libusb__asyncio.html">非同期デバイス入出力</a></li>
</ul>
<h1><a class="anchor" id="theory"></a> 論理レベルで転送</h1>
<p>論理レベルでは、USB転送は通常2つの部分で行われます。たとえば、エンドポイントからデータを読み取る場合:</p><ol type="1">
<li>データの要求がデバイスに送信されます</li>
<li>しばらくして、受信データがホストによって受信されます</li>
</ol>
<p>またはエンドポイントにデータを書き込む場合:</p>
<ol type="1">
<li>データはデバイスに送信されます</li>
<li>しばらくして、ホストはデータが転送されたという確認応答をデバイスから受信します。</li>
</ol>
<p>2つのステップの間に無期限の遅延がある場合があります。ユーザーが押すことができるボタンを備えた架空のUSB入力デバイスについて考えてみます。ボタンがいつ押されたかを判断するために、バルク・エンドポイントまたは割り込みエンドポイントでデータを読み取り、データが到着するのを待つ要求を送信する可能性があります。ユーザーがボタンを押すとデータが到着しますが、これは数時間後になる可能性があります。</p>
<p>libusbは、USB転送を実行するための同期インターフェイスと非同期インターフェイスの両方を提供します。主な違いは、同期インターフェイスが上記の両方のステップを1つの関数呼び出しに結合するのに対し、非同期インターフェイスはそれらを分離することです。</p>
<h1><a class="anchor" id="sync"></a> 同期インターフェイス</h1>
<p>同期入出力インターフェイスを使用すると、1回の関数呼び出しでUSB転送を実行できます。関数呼び出しが戻ると、転送が完了し、結果をパースできます。</p>
<p>あなたが以前にlibusb-0.1を使用したことがある場合、この入出力スタイルはおなじみのだと思います。libusb-0.1は同期インターフェイスのみを提供していました。</p>
<p>我々の入力デバイスの例では、ボタンの押下を読み取るために、以下のスタイルでコードを記述できます: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span
class="keywordtype">char</span> data[4];</div>
<div class="line"><span class="keywordtype">int</span> actual_length;</div>
<div class="line"><span class="keywordtype">int</span> r = <a class="code"
href="group__libusb__syncio.html#ga2f90957ccc1285475ae96ad2ceb1f58c">libusb_bulk_transfer</a>(dev_handle,
<a class="code"
href="group__libusb__desc.html#gga86c880af878493aa8f805c2aba654b8ba3829979c66e5344367f32f4a31d43613">LIBUSB_ENDPOINT_IN</a>,
data, <span class="keyword">sizeof</span>(data), &amp;actual_length, 0);</div>
<div class="line"><span class="keywordflow">if</span> (r == 0 &amp;&amp; actual_length ==
<span class="keyword">sizeof</span>(data)) {</div>
<div class="line">    <span class="comment">// 取引(transaction)の結果はそのデータ・バッファに現れます</span></div>
<div class="line">    <span class="comment">// データ・バッファをパースしボタン押下を報告します</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    error();</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>このモデルの主な利点は単純さです。1回の単純な関数呼び出しですべてを実行できます。</p>
<p>けれども、このインターフェイスには制限があります。アプリケーションは、取引がが完了するまで <a class="el"
href="group__libusb__syncio.html#ga2f90957ccc1285475ae96ad2ceb1f58c">libusb_bulk_transfer()</a>
内でスリープします。ユーザーがボタンを押すのに3時間かかる場合、アプリケーションはその3時間スリープします。実行はライブラリ内で束縛されます。つまり、その間、スレッド全体は役に立たなくなります。</p>
<p>もう1つの問題として、スレッドをその単一の取引に結び付けることにより、取引ごとに1つのスレッドを作成しない限り、複数のエンドポイントや複数のデバイスで入出力を同時に実行することが不可能なことです。</p>
<p>加えて、要求(request)の送信(submit)後に転送をキャンセルすることはできません。</p>
<p>同期APIの使用方法の詳細については <a class="el"
href="group__libusb__syncio.html">同期入出力API解説</a> を参照してください。</p>
<h1><a class="anchor" id="async"></a> 非同期インターフェイス</h1>
<p>非同期入出力は、libusb-1.0の最も重要な新機能です。これはより複雑なインターフェイスですが、上記のすべての問題を解決します。</p>
<p>入出力が完了するまでブロックする関数を提供する代わりに、libusbの非同期インターフェイスは、転送を開始してすぐに戻る非ブロック関数を提供します。アプリケーションは、この非ブロッキング関数へのコールバック関数ポインタを渡します。libusbは、取引が完了すると、取引の結果と共にこのコールバック関数を呼び出します。</p>
<p>非ブロッキング関数を介して送信(submit)された転送は、別の関数呼び出しでキャンセルできます。</p>
<p>このインターフェイスのノン・ブロッキングの性質により、スレッドを使用せずに、複数のデバイス上の複数のエンドポイントに対して同時に入出力を実行できます。</p>
<p>ただし、この追加された柔軟性には、いくつかの問題が伴います。</p><ul>
<li>軽量(lightweight)ライブラリであるために、libusbはスレッドを作成せず、アプリケーションがそれを呼び出しているときにのみ動作できます。イベントを処理する準備ができたら、アプリケーションはメイン・ループからlibusbを呼び出す必要があります。または、他の仕組みを使用して、libusbが必要な作業を実行できるようにする必要があります。</li>
<li>libusbは、転送タイムアウトを正確に処理するために、特定の固定箇所で呼び出す必要もあります。</li>
<li>メモリ処理はより複雑になります。スタックを持つ関数が転送コールバックの実行が終了するまで戻らないことが保証されていない限り、スタック・メモリを使用することはできません。</li>
<li>転送要求の送信は転送結果が処理される場所とは別の関数で行われるため、通常、ソース・コードの流れからある程度の線形性が失われます。
これは、以前の転送の結果に基づいて2番目の転送を送信する場合に特に明白になります。</li>
</ul>
<p>内部的には、libusbの同期インターフェイスは、非同期インターフェイスへの関数呼び出しの観点から表現されます。</p>
<p>非同期APIの使用方法の詳細については、 <a class="el"
href="group__libusb__asyncio.html">非同期入出力API</a> を参照してください。 </p>
</div></div>
<!-- contents -->
</div>
<!-- PageDoc -->
<div class="ttc" id="agroup__libusb__syncio_html_ga2f90957ccc1285475ae96ad2ceb1f58c"><div class="ttname"><a
href="group__libusb__syncio.html#ga2f90957ccc1285475ae96ad2ceb1f58c">libusb_bulk_transfer</a></div><div class="ttdeci">int libusb_bulk_transfer(libusb_device_handle *dev_handle, unsigned char
endpoint, unsigned char *data, int length, int *actual_length, unsigned int
timeout)</div><div class="ttdef"><b>定義:</b> sync.c:274</div></div>
<div class="ttc" id="agroup__libusb__desc_html_gga86c880af878493aa8f805c2aba654b8ba3829979c66e5344367f32f4a31d43613"><div class="ttname"><a
href="group__libusb__desc.html#gga86c880af878493aa8f805c2aba654b8ba3829979c66e5344367f32f4a31d43613">LIBUSB_ENDPOINT_IN</a></div><div class="ttdeci">@ LIBUSB_ENDPOINT_IN</div><div class="ttdoc">In: デバイスからホスト。</div><div class="ttdef"><b>定義:</b> libusb.h:322</div></div>

<!-- start footer part -->
<hr class="footer"/><address class="footer"><small> Generated on Fri Jul 9 2021 02:35:39 for libusb by &#160;<a
href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17 </small></address>
</body>
</html>
