<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libusb: マルチ・スレッド・アプリケーションと非同期入出力</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libusb &#160;<span id="projectnumber">1.0.24</span>
   </div>
   <div id="projectbrief">USBデバイスにアクセスするためのクロス・プラットフォームのユーザー・ライブラリ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>


<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license
magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt
GPL-v2 */ $(function() { initMenu('',false,false,'search.php','Search'); });
/* @license-end */</script>
<div id="main-nav"></div>
</div>
<!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">マルチ・スレッド・アプリケーションと非同期入出力 </div>  </div>
</div>
<!--header-->
<div class="contents">
<div class="textblock"><p>libusbはスレッド・セーフなライブラリですが、複数のスレッドからlibusbと対話するアプリケーションには追加の考慮事項を適用する必要があります。</p>
<p>対処しなければならない根本的な問題は、すべてのlibusb入出力が poll()/select()
システム・コールによるファイル・デスクリプターの監視を中心に展開していることです。これは <a class="el"
href="group__libusb__asyncio.html">非同期インターフェイス</a> では剥き出しになっていますが、 <a
class="el" href="group__libusb__syncio.html">同期インターフェイス</a>
は非同期インターフェイスの上に実装されるため、同じ考慮事項が適用されることに重々注意してください。</p>
<p>問題は、2つ以上のスレッドがlibusbのファイル記述子で poll() または select()
を同時に呼び出している場合、イベントが到着したときにそれらのスレッドの1つだけがウェイク・アップされることです。
他のスレッド達は何かが起こったことに全く気づかないでしょう。</p>
<p>以下の擬似コードについて考えてみます。この擬似コードは、非同期転送を送信してから、その完了を待ちます。このスタイルは、非同期インターフェイスの上に同期インターフェイスを実装できる方法の一つです(このページで説明されている複雑さのために、より高度ですが、libusbは同様のことを行います)。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> cb(<span class="keyword">struct</span>
<a class="code" href="structlibusb__transfer.html">libusb_transfer</a>
*transfer)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> *completed = transfer-&gt;<a
class="code"
href="structlibusb__transfer.html#ab75ab3e7185f08e07a1ae858a35ebb7b">user_data</a>;</div>
<div class="line">     *completed = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> myfunc() {</div>
<div class="line">    <span class="keyword">struct </span><a class="code"
href="structlibusb__transfer.html">libusb_transfer</a> *transfer;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span
class="keywordtype">char</span> <a class="code"
href="structlibusb__transfer.html#a7fa594567e074191ce8f28b5fb4a3bea">buffer</a>[LIBUSB_CONTROL_SETUP_SIZE]
__attribute__ ((aligned (2)));</div>
<div class="line">    <span class="keywordtype">int</span> completed = 0;</div>
<div class="line"> </div>
<div class="line">    transfer = <a class="code"
href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer</a>(0);</div>
<div class="line">    <a class="code"
href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup</a>(<a
class="code"
href="structlibusb__transfer.html#a7fa594567e074191ce8f28b5fb4a3bea">buffer</a>,</div>
<div class="line">        <a class="code"
href="group__libusb__misc.html#gga0b0933ae70744726cde11254c39fac91a1585f40d2a73c752a5f60688612c1345">LIBUSB_REQUEST_TYPE_VENDOR</a>
| <a class="code"
href="group__libusb__desc.html#gga86c880af878493aa8f805c2aba654b8ba940484c16d44bdfc6eccc2de7a9ffcb2">LIBUSB_ENDPOINT_OUT</a>,
0x04, 0x01, 0, 0);</div>
<div class="line">    <a class="code"
href="group__libusb__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e">libusb_fill_control_transfer</a>(transfer,
dev, <a class="code"
href="structlibusb__transfer.html#a7fa594567e074191ce8f28b5fb4a3bea">buffer</a>,
cb, &amp;completed, 1000);</div>
<div class="line">    <a class="code"
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer</a>(transfer);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!completed) {</div>
<div class="line">        poll(libusb file descriptors, 120*1000);</div>
<div class="line">        <span class="keywordflow">if</span> (poll indicates activity)</div>
<div class="line">            <a class="code"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout</a>(ctx,
&amp;zero_tv);</div>
<div class="line">    }</div>
<div class="line">    printf(<span class="stringliteral">&quot;completed!&quot;</span>);</div>
<div class="line">    <span class="comment">// other code here</span></div>
<div class="line">}</div>
</div><!-- fragment -->
<p>ここでは、条件に対して非同期イベントの完了を<em>直列化</em>しています。条件は特定の転送の完了です。 poll()
ループには、何も起こらない状況でのCPU使用率を最小限に抑えるために、長いタイムアウトがあります(わりと無制限である可能性があります)。</p>
<p>これがlibusbのファイル・デスクリプターをポーリングしている唯一のスレッドである場合、問題はありません。別のスレッドが関心のあるイベントを飲み込む危険はありません。一方、同じデスクリプターをポーリングしている別のスレッドがある場合
、関心のあるイベントを受信する可能性があります。この状況では、 <code>myfunc()</code>
は、<em>最大120秒後のループの次の反復で</em>転送が完了したことのみを認識します。明らかに2分の遅延は望ましくありませんが、だからと言って、この問題を回避するために短いタイムアウトを使用することは考えないでください。</p>
<p>ここでの解決策は、2つのスレッドがファイル・デスクリプターを同時にポーリングしないようにすることです。
これの単純な実装はライブラリの機能に影響を与えるため、libusbは、機能が失われないようにするために、以下に説明する仕組みを提供します。</p>
<p>先に進む前に、libusbで覆われたすべてのイベント処理手順が以下に記載されている仕組みに完全に準拠していることに言及する価値があります。これには、
<a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
とその変種、およびすべての同期入出力O関数が含まれます。libusbは、この頭痛の種をあなたから隠します。</p>
<h1><a class="anchor" id="Using"></a> 複数スレッドからの libusb_handle_events() 呼び出し</h1>
<p><a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
と同期入出力関数のみを使用している場合でも、競合状態が発生する可能性があります。以下のように <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
を使用して、上記を解決したくなるかもしれません:</p>
<div class="fragment"><div class="line"><a class="code"
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer</a>(transfer);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (!completed) {</div>
<div class="line">    <a class="code"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events</a>(ctx);</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;completed!&quot;</span>);</div>
</div><!-- fragment -->
<p>ただし、これには、完了のチェックと <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
によるイベント・ロック取得との間で競合があるため、別のスレッドが転送を完了し、タイムアウトまたは別のイベントが発生するまでこのスレッドがハングする可能性があります。libusbの同期API実装でこれを修正する
commit 6696512aade99bb15d6792af90ae329af270eba6 も参照してください。</p>
<p>この競合を修正するには、イベント・ロックを取得した後にのみ完了した変数をチェックする必要があります。つまり、ロックを気にせずに <a
class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
を呼び出すという考え方は通用しなくなります。
これが、libusb-1.0.9が新しい <a class="el"
href="group__libusb__poll.html#ga43e52b912a760b41a0cf8a4a472fbd5b">libusb_handle_events_timeout_completed()</a>
関数と <a class="el"
href="group__libusb__poll.html#ga0bc99f39e4cf5ad393cd5936c36037d1">libusb_handle_events_completed()</a>
関数を導入した理由です。これらの関数は、ロックを取得した後に完了チェックを実行します。</p>
<div class="fragment"><div class="line"><a class="code"
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer</a>(transfer);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (!completed) {</div>
<div class="line">    <a class="code"
href="group__libusb__poll.html#ga0bc99f39e4cf5ad393cd5936c36037d1">libusb_handle_events_completed</a>(ctx,
&amp;completed);</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;completed!&quot;</span>);</div>
</div><!-- fragment -->
<p>これにより、我々の例の競合がうまく修正されます。なお、単一の転送を送信してその完了を待つだけの場合は、同期入出力機能の1つを使用する方がはるかに簡単であることに注意してください。</p>
<dl class="section note"><dt>注意</dt><dd><code>complete</code>変数は、イベント・ロックを保持しつつ変更する必要があります。そうしないと、競合状態が引き続き存在する可能性があります。上記のように転送コールバック内からこれを行うのが最も簡単です。</dd></dl>
<h1><a class="anchor" id="eventlock"></a> イベント・ロック(lock)</h1>
<p>問題は、libusbがファイル・デスクリプターを公開して、非同期USB入出力を既存のメイン・ループに統合できるようにし、libusbの背後で効果的に作業を行えるようにするという事実を考慮する場合です。libusbのファイル・デスクリプターを取得して、自分で
poll()/select() に渡す場合は、関連する問題に注意する必要があります。</p>
<p>導入される最初の概念は、イベント・ロックです。
イベント・ロックは、イベントを処理するスレッド達を直列化するために使用されます。これにより、一度に1つのスレッドのみがイベントを処理します。</p>
<p>あなたは、 <a class="el"
href="group__libusb__poll.html#gaa72153938dc4f34decfacbc6cc6237ef">libusb_lock_events()</a>
を使用してlibusbファイル・デスクリプターをポーリングする前に、イベント・ロックを取得する必要があります。 <a class="el"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events()</a>を使用して
poll()/select() ループを中止したら、すぐにロックを解除する必要があります。</p>
<h1><a class="anchor" id="threadwait"></a> 他のスレッドに作業を任せる</h1>
<p>イベント・ロックは解決策の重要な部分ですが、それだけでは十分ではありません。 あなたは以下で十分かどうか疑問に思うかもしれません… </p><div class="fragment"><div class="line"><a class="code"
href="group__libusb__poll.html#gaa72153938dc4f34decfacbc6cc6237ef">libusb_lock_events</a>(ctx);</div>
<div class="line"><span class="keywordflow">while</span> (!completed) {</div>
<div class="line">    poll(libusb file descriptors, 120*1000);</div>
<div class="line">    <span class="keywordflow">if</span> (poll indicates activity)</div>
<div class="line">        <a class="code"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout</a>(ctx,
&amp;zero_tv);</div>
<div class="line">}</div>
<div class="line"><a class="code"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events</a>(ctx);</div>
</div><!-- fragment -->
<p> …そして答えはこれではありません。なぜなら、これは、上記のコードの転送が完了するまでに長い時間(たとえば30秒)かかる場合があり、転送が完了するまでロックが解除されないためです。</p>
<p>イベント処理を実行したい同様のコードを持つ別のスレッドが、数ミリ秒後に完了する転送で動作している可能性があります。完了までの時間が非常に短いにもかかわらず、他のスレッドは、ロックの競合のために上記のコードが終了するまで(30秒後まで)転送のステータスを確認できません。</p>
<p>これを解決するために、libusbは、別のスレッドがいつイベントを処理しているかを判別するメカニズムを提供します。また、イベント処理スレッドがイベントを完了するまでスレッドをブロックするメカニズムも提供します(このメカニズムには、ファイル・デスクリプターのポーリングは含まれません)。</p>
<p>別のスレッドが現在イベントを処理していることを確認した後、 あなたは <a class="el"
href="group__libusb__poll.html#ga150865a3f35c38173d688efa7ee52929">libusb_lock_event_waiters()</a>
を使用して<em>イベント待ちロック</em>を取得します。
次に、あなたは、他のスレッドがまだイベントを処理していることを再確認し、処理している場合は、 <a class="el"
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event()</a>
を呼び出します。</p>
<p><a class="el"
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event()</a>
は、イベントが発生するまで、またはスレッドがイベント・ロックを解放するまで、あなたのアプリケーションをスリープ状態にします。これらのどれかが発生すると、スレッドがウェイクアップされるので、待機していた状態を再確認する必要があり、また、別のスレッドがイベントを処理していることを再確認する必要があります。そうでない場合は、イベント自体の処理を開始する必要があります。</p>
<p>これは、擬似コードとして以下のようになります: </p><div class="fragment"><div class="line">retry:</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code"
href="group__libusb__poll.html#ga6e5a116d5c9498ca4a0e29587fec1a05">libusb_try_lock_events</a>(ctx)
== 0) {</div>
<div class="line">    <span class="comment">// 我々はイベント・ロックを取得しました: 我々独自のイベント処理を行います</span></div>
<div class="line">    <span class="keywordflow">while</span> (!completed) {</div>
<div class="line">        <span class="keywordflow">if</span> (!<a class="code"
href="group__libusb__poll.html#ga63592b28c265185d9469d1e6920d8373">libusb_event_handling_ok</a>(ctx))
{</div>
<div class="line">            <a class="code"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events</a>(ctx);</div>
<div class="line">            <span class="keywordflow">goto</span> retry;</div>
<div class="line">        }</div>
<div class="line">        poll(libusb file descriptors, 120*1000);</div>
<div class="line">        <span class="keywordflow">if</span> (poll indicates activity)</div>
<div class="line">            <a class="code"
href="group__libusb__poll.html#ga71da081f97afa3bf68aed8e372254e8f">libusb_handle_events_locked</a>(ctx,
0);</div>
<div class="line">    }</div>
<div class="line">    <a class="code"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events</a>(ctx);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// 別のスレッドがイベント処理を行っています。</span></div>
<div class="line">    <span class="comment">// イベントが完了したことを我々に通知(signal)するのを待ちます</span></div>
<div class="line">    <a class="code"
href="group__libusb__poll.html#ga150865a3f35c38173d688efa7ee52929">libusb_lock_event_waiters</a>(ctx);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!completed) {</div>
<div class="line">        <span class="comment">// 今やイベント待ちがロックされたので、</span></div>
<div class="line">        <span class="comment">// ダブル・スレッドはまだイベントを処理しています。</span></div>
<div class="line">        <span class="comment">// (この箇所に到達するまでにイベントの処理を停止した可能性があります)</span></div>
<div class="line">        <span class="keywordflow">if</span> (!<a class="code"
href="group__libusb__poll.html#ga3a0a6e8be310c20f1ca68722149f9dbf">libusb_event_handler_active</a>(ctx))
{</div>
<div class="line">            <span class="comment">// イベントを処理している者は誰も居ません。もう一度やり直してください</span></div>
<div class="line">            <a class="code"
href="group__libusb__poll.html#ga41d7716458c11ee02d0deb19a31233ed">libusb_unlock_event_waiters</a>(ctx);</div>
<div class="line">            <span class="keywordflow">goto</span> retry;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <a class="code"
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event</a>(ctx,
NULL);</div>
<div class="line">    }</div>
<div class="line">    <a class="code"
href="group__libusb__poll.html#ga41d7716458c11ee02d0deb19a31233ed">libusb_unlock_event_waiters</a>(ctx);</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;completed!\n&quot;</span>);</div>
</div><!-- fragment -->
<p>上記のコードをざっと見ると、これは1つのイベント待ちしかサポートできない(したがって、合計2つの競合するスレッドで、もう1つはイベント処理を実行しています)、イベント待ちがイベントを待っている間にイベント待ちをロックしたように見えます。ただし、
<a class="el"
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event()</a>
は待機中に実際にロックを解除し、続行する前にロックを再取得するため、システムは複数のイベント待ちをサポートします。</p>
<p>我々は、これで、誰もイベントを処理していない状況を動的に処理できるコードを実装しました(つまり、自分で処理する必要があります)。また、別のスレッドがイベント処理を実行している状況も処理できます(つまり、それらに便乗できます)。また、2つの組み合わせを処理する機能も備えています。たとえば、別のスレッドがイベント処理を実行していますが、何らかの理由で条件が満たされる前に処理を停止するため、イベント処理を引き継ぎます。</p>
<p>上記の擬似コードでは、4つの関数が導入されました。 それらの重要性は、上記のコードから明らかです。</p><ol type="1">
<li><a class="el"
href="group__libusb__poll.html#ga6e5a116d5c9498ca4a0e29587fec1a05">libusb_try_lock_events()</a>
は、イベント・ロックを取得しようと試みますが、競合した場合は失敗コードを返す非ブロッキング関数です。</li>
<li><a class="el"
href="group__libusb__poll.html#ga63592b28c265185d9469d1e6920d8373">libusb_event_handling_ok()</a>
は、あなたのスレッドがイベント処理を実行することをlibusbがまだ不満を持っていないことを確認します。libusbがイベント・ハンドラーに割り込む必要がある場合があり、これにより、割り込まれたかどうかを確認できます。この関数が0を返す場合、正しい動作は、イベント処理ロックを放棄してから、サイクルを繰り返すことです。
次の <a class="el"
href="group__libusb__poll.html#ga6e5a116d5c9498ca4a0e29587fec1a05">libusb_try_lock_events()</a>
は失敗するため、イベント待ちになります。 詳細については、以下の <a class="el"
href="libusb_mtasync.html#fullstory">全体の流れ</a> をお読みください。</li>
<li><a class="el"
href="group__libusb__poll.html#ga71da081f97afa3bf68aed8e372254e8f">libusb_handle_events_locked()</a>
は、イベント・ロックを保持しながら呼び出すことができる <a class="el"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout()</a>
の変種です。 <a class="el"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout()</a>
自体は上記と同様のロジックを実装しているため、ここでの場合のように、あなたが「libusbの背後で作業している」ときは呼び出さないでください。</li>
<li><a class="el"
href="group__libusb__poll.html#ga3a0a6e8be310c20f1ca68722149f9dbf">libusb_event_handler_active()</a>
は、誰かが現在イベント・ロックを保持しているかどうかを判断します</li>
</ol>
<p>あなたは <a class="el"
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event()</a>
でブロックされたすべてのスレッドをウェイクアップする関数が無いのを疑問に思われるかもしれません。これは、libusbがこれを内部で実行できるためです。誰かが
<a class="el"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events()</a>
を呼び出したとき、または転送が完了したとき(コールバックが戻った後の時点)で、そのようなすべてのスレッドをウェイクアップします。</p>
<h2><a class="anchor" id="fullstory"></a> 全体の流れ</h2>
<p>上記の説明で普通は十分ですが、あなたが問題についてさらに深く考察している場合、libusbの内部に関するいくつかの質問が残っているかもしれません。もし興味がある場合は以下を読み進めてください。そうでない場合は、混乱を避けるためにこの節は飛ばして構いません。</p>
<p>まず頭に浮かぶ質問は、別のスレッドがイベント処理を行っている間に、あるスレッドがポーリングする必要のあるファイル・デスクリプターのセットを変更した場合はどうなるか？ということです。</p>
<p>これが発生する可能性がある状況は2つあります。</p><ol type="1">
<li><a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
は別のファイル・デスクリプターをポーリング・セットに追加するため、イベント・ハンドラーを中断して再起動し、新しいデスクリプターを取得することが望ましいです。</li>
<li><a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>
は、ポーリング・セットからファイル・デスクリプターを削除します。ここではさまざまな競合状態が発生する可能性があるため、その時点では誰もイベント処理を行っていないことが重要です。</li>
</ol>
<p>libusbはこれらの問題を内部で処理するため、アプリケーション開発者はデバイスをオープンしたりクローズしたりするときにイベント・ハンドラーを停止する必要はありません。最初に
<a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>
の状況に焦点を当てて、その仕組みを説明します:</p>
<ol type="1">
<li>利用準備(initialization)中に、libusbは内部パイプを開き、この内部パイプの読み取り端をポーリングされるファイル・デスクリプターのセットに追加します。</li>
<li><a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>
処理中に、libusbはこのイベント・パイプにダミー・データを書き込みます。これにより、イベント・ハンドラが直ちに中断されます。libusbは、この優先度の高いイベントのイベント・ハンドラーに割り込もうとしていることも内部的に記録します。</li>
<li>この時点で、上記の関数の一部は異なる動作を開始します:<ul>
<li><a class="el"
href="group__libusb__poll.html#ga63592b28c265185d9469d1e6920d8373">libusb_event_handling_ok()</a>
は1を返し始め、イベント処理を続行しても問題がないことを示します。</li>
<li><a class="el"
href="group__libusb__poll.html#ga6e5a116d5c9498ca4a0e29587fec1a05">libusb_try_lock_events()</a>
は1を返し始め、ロックが競合していない場合でも、別のスレッドがイベント処理ロックを保持していることを示します。</li>
<li><a class="el"
href="group__libusb__poll.html#ga3a0a6e8be310c20f1ca68722149f9dbf">libusb_event_handler_active()</a>
は1を返し始め、それが真でない場合でも、別のスレッドがイベント処理を行っていることを示します。</li>
</ul>
</li>
<li>上記の振る舞いの変更により、イベント・ハンドラーはイベント・ロックを非常に迅速に停止および放棄し、優先度の高い <a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>
操作にイベント・ロックを取得するための「タダ乗り」を提供します。イベント処理を行うために競合しているすべてのスレッドは、イベント待ちになります。</li>
<li><a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>
内にイベント・ロック達が保持されているので、libusbは、誰もそれらのデスクリプターをポーリングしたり、ポーリング・セットにアクセスしようとしたりしていないことが分かり、ポーリング・セットからファイル記述子を安全に削除できます。</li>
<li>イベント・ロックを取得した後、クローズ操作は非常に迅速に(通常はミリ秒単位で)完了し、すぐにイベント・ロックを解放します。</li>
<li>同時に、 <a class="el"
href="group__libusb__poll.html#ga63592b28c265185d9469d1e6920d8373">libusb_event_handling_ok()</a>
とその友人達の振る舞いは、文書化された元の行動に戻ります。</li>
<li>イベント・ロックを解除すると、イベントを待機しているスレッドがウェイクアップされ、再びイベント・ハンドラーになるための競合が開始されます。それらのどれか1つは成功します。その後、ポーリング・デスクリプターのリストを再取得し、USB入出力は通常どおり続行されます。</li>
</ol>
<p><a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
も同様ですが、実際にはもっと単純なパターンです。 <a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
の呼び出し時は以下のとおりです:</p>
<ol type="1">
<li>デバイスがオープンされ、ファイル・デスクリプターがポーリング・セットに追加されます。</li>
<li>libusbはイベント・パイプでダミー・データを送信し、ポーリング・デスクリプター・セットを変更しようとしていることを記録します。</li>
<li>イベント・ハンドラーが割り込み中断され、 <a class="el"
href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>
と同じ振る舞いの変更が有効になり、すべてのイベント処理スレッドがイベント待ちになります。</li>
<li><a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
のコードは、イベント・ロックにただ乗りでアクセスできます。</li>
<li>イベント・ハンドラーが正常に一時停止されたので、安心して <a class="el"
href="group__libusb__dev.html#ga3f184a8be4488a767b2e0ae07e76d1b0">libusb_open()</a>
はイベント・ロックを解放します。</li>
<li>イベント待ちスレッドはすべてウェイクアップされ、再びイベント・ハンドラーになるために競合します。そのうちイベント・ハンドラーになる事に成功したものは、新しいデバイスの追加を含むポーリング・デスクリプターのリストを再度取得します。</li>
</ol>
<h2><a class="anchor" id="concl"></a> おわりに</h2>
<p>上記は少し複雑に思えるかもしれませんが、望み通りであるためには、なぜそのような複雑さが必要なのかを明らかにしました。
また、これはlibusbのファイル・デスクリプターを取得して独自のポーリング・ループに統合するアプリケーションにのみ適用されることを忘れないでください。</p>
<p>あなたの2つのスレッドが同時にデスクリプターをポーリングできるとは思わない時、マルチ・スレッド・アプリケーションが上記のルールとロックの一部を無視しても問題ないと判断する場合があります。その場合は、その心配する必要がないので、それはあなたにとって朗報です。ただし、同期入出力関数は内部でイベント処理を行うことに注意してください。1つのスレッドがループ内でイベント処理を実行し(上記の規則とロック方法論を実装せずに)、別のスレッドが同期USB転送を送信しようとすると、2つのスレッドが同じデスクリプターを監視することになり、上述の望ましくない振る舞いが発生します。その解決策は、あなたがポーリング・スレッドを規則に従って上演することです。同期入出力関数はそのように動き、そしてその結果はこれらが完全に調和する結果になります。</p>
<p>イベント処理を行う専用スレッドがある場合、イベント処理ロックを長期間取得することは完全に合法です。他のスレッドから呼び出す同期入出力関数は、上記の「イベント待ち」メカニズムに透過的にフォールバックします。イベント処理スレッドが適用しなければならない唯一の考慮事項は、
<a class="el"
href="group__libusb__poll.html#ga63592b28c265185d9469d1e6920d8373">libusb_event_handling_ok()</a>
に関連するものです。すべての poll() の前にこれを呼び出し、指示された場合はイベント・ロックを放棄する必要があります。 </p>
</div></div>
<!-- contents -->
</div>
<!-- PageDoc -->
<div class="ttc" id="agroup__libusb__desc_html_gga86c880af878493aa8f805c2aba654b8ba940484c16d44bdfc6eccc2de7a9ffcb2"><div class="ttname"><a
href="group__libusb__desc.html#gga86c880af878493aa8f805c2aba654b8ba940484c16d44bdfc6eccc2de7a9ffcb2">LIBUSB_ENDPOINT_OUT</a></div><div class="ttdeci">@ LIBUSB_ENDPOINT_OUT</div><div class="ttdoc">Out: ホストからデバイスへ。</div><div class="ttdef"><b>定義:</b> libusb.h:319</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga3a0a6e8be310c20f1ca68722149f9dbf"><div class="ttname"><a
href="group__libusb__poll.html#ga3a0a6e8be310c20f1ca68722149f9dbf">libusb_event_handler_active</a></div><div class="ttdeci">int libusb_event_handler_active(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:1887</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga4989086e3f0327f3886a4c474ec7c327"><div class="ttname"><a
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events</a></div><div class="ttdeci">int libusb_handle_events(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:2407</div></div>
<div class="ttc" id="astructlibusb__transfer_html_a7fa594567e074191ce8f28b5fb4a3bea"><div class="ttname"><a
href="structlibusb__transfer.html#a7fa594567e074191ce8f28b5fb4a3bea">libusb_transfer::buffer</a></div><div class="ttdeci">unsigned char * buffer</div><div class="ttdoc">Data buffer.</div><div class="ttdef"><b>定義:</b> libusb.h:1273</div></div>
<div class="ttc" id="agroup__libusb__asyncio_html_ga5447311149ec2bd954b5f1a640a8e231"><div class="ttname"><a
href="group__libusb__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup</a></div><div class="ttdeci">static void libusb_fill_control_setup(unsigned char *buffer, uint8_t
bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t
wLength)</div><div class="ttdef"><b>定義:</b> libusb.h:1525</div></div>
<div class="ttc" id="agroup__libusb__poll_html_gacefbeabdd3409490dc4678f00779c165"><div class="ttname"><a
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events</a></div><div class="ttdeci">void libusb_unlock_events(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:1823</div></div>
<div class="ttc" id="agroup__libusb__asyncio_html_ga13cc69ea40c702181c430c950121c000"><div class="ttname"><a
href="group__libusb__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer</a></div><div class="ttdeci">struct libusb_transfer * libusb_alloc_transfer(int iso_packets)</div><div class="ttdef"><b>定義:</b> io.c:1285</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga0bc99f39e4cf5ad393cd5936c36037d1"><div class="ttname"><a
href="group__libusb__poll.html#ga0bc99f39e4cf5ad393cd5936c36037d1">libusb_handle_events_completed</a></div><div class="ttdeci">int libusb_handle_events_completed(libusb_context *ctx, int *completed)</div><div class="ttdef"><b>定義:</b> io.c:2429</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga41d7716458c11ee02d0deb19a31233ed"><div class="ttname"><a
href="group__libusb__poll.html#ga41d7716458c11ee02d0deb19a31233ed">libusb_unlock_event_waiters</a></div><div class="ttdeci">void libusb_unlock_event_waiters(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:1963</div></div>
<div class="ttc" id="agroup__libusb__asyncio_html_gabb0932601f2c7dad2fee4b27962848ce"><div class="ttname"><a
href="group__libusb__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer</a></div><div class="ttdeci">int libusb_submit_transfer(struct libusb_transfer *transfer)</div><div class="ttdef"><b>定義:</b> io.c:1489</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga150865a3f35c38173d688efa7ee52929"><div class="ttname"><a
href="group__libusb__poll.html#ga150865a3f35c38173d688efa7ee52929">libusb_lock_event_waiters</a></div><div class="ttdeci">void libusb_lock_event_waiters(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:1952</div></div>
<div class="ttc" id="agroup__libusb__poll_html_gaa72153938dc4f34decfacbc6cc6237ef"><div class="ttname"><a
href="group__libusb__poll.html#gaa72153938dc4f34decfacbc6cc6237ef">libusb_lock_events</a></div><div class="ttdeci">void libusb_lock_events(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:1808</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga63592b28c265185d9469d1e6920d8373"><div class="ttname"><a
href="group__libusb__poll.html#ga63592b28c265185d9469d1e6920d8373">libusb_event_handling_ok</a></div><div class="ttdeci">int libusb_event_handling_ok(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:1858</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga6deff4c7d3a6c04bb9ec9fd259b48933"><div class="ttname"><a
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout</a></div><div class="ttdeci">int libusb_handle_events_timeout(libusb_context *ctx, struct timeval *tv)</div><div class="ttdef"><b>定義:</b> io.c:2387</div></div>
<div class="ttc" id="agroup__libusb__poll_html_gae22755d523560be2867be7d09034ca50"><div class="ttname"><a
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event</a></div><div class="ttdeci">int libusb_wait_for_event(libusb_context *ctx, struct timeval *tv)</div><div class="ttdef"><b>定義:</b> io.c:1995</div></div>
<div class="ttc" id="astructlibusb__transfer_html"><div class="ttname"><a href="structlibusb__transfer.html">libusb_transfer</a></div><div class="ttdef"><b>定義:</b> libusb.h:1222</div></div>
<div class="ttc" id="astructlibusb__transfer_html_ab75ab3e7185f08e07a1ae858a35ebb7b"><div class="ttname"><a
href="structlibusb__transfer.html#ab75ab3e7185f08e07a1ae858a35ebb7b">libusb_transfer::user_data</a></div><div class="ttdeci">void * user_data</div><div class="ttdoc">User context data.</div><div class="ttdef"><b>定義:</b> libusb.h:1270</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga71da081f97afa3bf68aed8e372254e8f"><div class="ttname"><a
href="group__libusb__poll.html#ga71da081f97afa3bf68aed8e372254e8f">libusb_handle_events_locked</a></div><div class="ttdeci">int libusb_handle_events_locked(libusb_context *ctx, struct timeval *tv)</div><div class="ttdef"><b>定義:</b> io.c:2457</div></div>
<div class="ttc" id="agroup__libusb__misc_html_gga0b0933ae70744726cde11254c39fac91a1585f40d2a73c752a5f60688612c1345"><div class="ttname"><a
href="group__libusb__misc.html#gga0b0933ae70744726cde11254c39fac91a1585f40d2a73c752a5f60688612c1345">LIBUSB_REQUEST_TYPE_VENDOR</a></div><div class="ttdeci">@ LIBUSB_REQUEST_TYPE_VENDOR</div><div class="ttdoc">Vendor.</div><div class="ttdef"><b>定義:</b> libusb.h:405</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga6e5a116d5c9498ca4a0e29587fec1a05"><div class="ttname"><a
href="group__libusb__poll.html#ga6e5a116d5c9498ca4a0e29587fec1a05">libusb_try_lock_events</a></div><div class="ttdeci">int libusb_try_lock_events(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:1765</div></div>
<div class="ttc" id="agroup__libusb__asyncio_html_ga3a8513ed87229fe2c9771ef0bf17206e"><div class="ttname"><a
href="group__libusb__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e">libusb_fill_control_transfer</a></div><div class="ttdeci">static void libusb_fill_control_transfer(struct libusb_transfer *transfer,
libusb_device_handle *dev_handle, unsigned char *buffer,
libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)</div><div class="ttdef"><b>定義:</b> libusb.h:1574</div></div>

<!-- start footer part -->
<hr class="footer"/><address class="footer"><small> Generated on Fri Jul 9 2021 02:35:39 for libusb by &#160;<a
href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17 </small></address>
</body>
</html>
