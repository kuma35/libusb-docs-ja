<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libusb: ポーリングとタイミング</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libusb &#160;<span id="projectnumber">1.0.24</span>
   </div>
   <div id="projectbrief">USBデバイスにアクセスするためのクロス・プラットフォームのユーザー・ライブラリ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>


<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license
magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt
GPL-v2 */ $(function() { initMenu('',false,false,'search.php','Search'); });
/* @license-end */</script>
<div id="main-nav"></div>
</div>
<!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">データ構造体</a> &#124; <a
href="#typedef-members">Typedef</a> &#124; <a href="#func-members">関数</a>  </div>
  <div class="headertitle">
<div class="title">ポーリングとタイミング</div>  </div>
</div>
<!--header-->
<div class="contents">

<p>このページでは、イベントとタイミングをポーリングするためのlibusbの機能について説明します。これらの関数は <a class="el"
href="group__libusb__asyncio.html">非同期API</a> のユーザーにのみ必要です。より単純な <a
class="el" href="group__libusb__syncio.html">同期API</a>
のみを使用している場合、これらの関数を呼び出す必要はありません。 <a href="#details">詳細…</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> データ構造体</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibusb__pollfd.html">libusb_pollfd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a> Typedef</h2></td></tr>
<tr class="memitem:ga2962a11284b09a3f18936d8f73a43804"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga2962a11284b09a3f18936d8f73a43804">libusb_pollfd_added_cb</a>)
(int fd, short events, void *user_data)</td></tr>
<tr class="separator:ga2962a11284b09a3f18936d8f73a43804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32aa803f54cfb5bfe8b41747e6b62af5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga32aa803f54cfb5bfe8b41747e6b62af5">libusb_pollfd_removed_cb</a>)
(int fd, void *user_data)</td></tr>
<tr class="separator:ga32aa803f54cfb5bfe8b41747e6b62af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a> 関数</h2></td></tr>
<tr class="memitem:ga6e5a116d5c9498ca4a0e29587fec1a05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga6e5a116d5c9498ca4a0e29587fec1a05">libusb_try_lock_events</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:ga6e5a116d5c9498ca4a0e29587fec1a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa72153938dc4f34decfacbc6cc6237ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#gaa72153938dc4f34decfacbc6cc6237ef">libusb_lock_events</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:gaa72153938dc4f34decfacbc6cc6237ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefbeabdd3409490dc4678f00779c165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:gacefbeabdd3409490dc4678f00779c165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63592b28c265185d9469d1e6920d8373"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga63592b28c265185d9469d1e6920d8373">libusb_event_handling_ok</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:ga63592b28c265185d9469d1e6920d8373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0a6e8be310c20f1ca68722149f9dbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga3a0a6e8be310c20f1ca68722149f9dbf">libusb_event_handler_active</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:ga3a0a6e8be310c20f1ca68722149f9dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188b6c50944b49f122ccfd45b93fa9f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga188b6c50944b49f122ccfd45b93fa9f2">libusb_interrupt_event_handler</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:ga188b6c50944b49f122ccfd45b93fa9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150865a3f35c38173d688efa7ee52929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga150865a3f35c38173d688efa7ee52929">libusb_lock_event_waiters</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:ga150865a3f35c38173d688efa7ee52929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d7716458c11ee02d0deb19a31233ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga41d7716458c11ee02d0deb19a31233ed">libusb_unlock_event_waiters</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:ga41d7716458c11ee02d0deb19a31233ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22755d523560be2867be7d09034ca50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, struct timeval *tv)</td></tr>
<tr class="separator:gae22755d523560be2867be7d09034ca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43e52b912a760b41a0cf8a4a472fbd5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga43e52b912a760b41a0cf8a4a472fbd5b">libusb_handle_events_timeout_completed</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, struct timeval *tv, int *completed)</td></tr>
<tr class="separator:ga43e52b912a760b41a0cf8a4a472fbd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6deff4c7d3a6c04bb9ec9fd259b48933"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, struct timeval *tv)</td></tr>
<tr class="separator:ga6deff4c7d3a6c04bb9ec9fd259b48933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4989086e3f0327f3886a4c474ec7c327"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:ga4989086e3f0327f3886a4c474ec7c327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc99f39e4cf5ad393cd5936c36037d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga0bc99f39e4cf5ad393cd5936c36037d1">libusb_handle_events_completed</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, int *completed)</td></tr>
<tr class="separator:ga0bc99f39e4cf5ad393cd5936c36037d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71da081f97afa3bf68aed8e372254e8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga71da081f97afa3bf68aed8e372254e8f">libusb_handle_events_locked</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, struct timeval *tv)</td></tr>
<tr class="separator:ga71da081f97afa3bf68aed8e372254e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a654315636bebf404c1784429f06df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#gae7a654315636bebf404c1784429f06df">libusb_pollfds_handle_timeouts</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:gae7a654315636bebf404c1784429f06df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bc6f5bc71a43845244912da6679f634"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga5bc6f5bc71a43845244912da6679f634">libusb_get_next_timeout</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, struct timeval *tv)</td></tr>
<tr class="separator:ga5bc6f5bc71a43845244912da6679f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7b2deb193f2e9ffda5e727361d7e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga1b7b2deb193f2e9ffda5e727361d7e67">libusb_set_pollfd_notifiers</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx, <a class="el"
href="group__libusb__poll.html#ga2962a11284b09a3f18936d8f73a43804">libusb_pollfd_added_cb</a>
added_cb, <a class="el"
href="group__libusb__poll.html#ga32aa803f54cfb5bfe8b41747e6b62af5">libusb_pollfd_removed_cb</a>
removed_cb, void *user_data)</td></tr>
<tr class="separator:ga1b7b2deb193f2e9ffda5e727361d7e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c27dcf8a95d2a3a03cfb7dd37eae63"><td class="memItemLeft" align="right" valign="top">const struct <a class="el"
href="structlibusb__pollfd.html">libusb_pollfd</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#ga54c27dcf8a95d2a3a03cfb7dd37eae63">libusb_get_pollfds</a>
(<a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*ctx)</td></tr>
<tr class="separator:ga54c27dcf8a95d2a3a03cfb7dd37eae63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad703b12ab275b6420c2c27e6279c955f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el"
href="group__libusb__poll.html#gad703b12ab275b6420c2c27e6279c955f">libusb_free_pollfds</a>
(const struct <a class="el"
href="structlibusb__pollfd.html">libusb_pollfd</a> **pollfds)</td></tr>
<tr class="separator:gad703b12ab275b6420c2c27e6279c955f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳細説明</h2>
<p>このページでは、イベントとタイミングをポーリングするためのlibusbの機能について説明します。これらの関数は <a class="el"
href="group__libusb__asyncio.html">非同期API</a> のユーザーにのみ必要です。より単純な <a
class="el" href="group__libusb__syncio.html">同期API</a>
のみを使用している場合、これらの関数を呼び出す必要はありません。 </p>
<p>ここで説明する機能の正当性については、非同期API文書の <a class="el"
href="group__libusb__asyncio.html#asyncevent">イベント処理</a>
節で既に説明しています。要約すると、libusbはイベント処理用の内部スレッドを作成しないため、保留中のイベントを処理できるように、特定の時点でアプリケーションがlibusbを呼び出すことに頼っています。</p>
<p>あなたのメインループは、おそらくすでに他のイベント・ソース(キーボードのキーの押下、マウスの動き、ネットワーク・ソケットなど)のファイル・デスクリプターのセットで
poll() または select() またはその変種を呼び出しています。あなたは次に、libusbのファイル・デスクリプターを
poll()/select() 呼び出しに追加します。これらのデスクリプターでアクティビティが検出されたら、 <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
を呼び出す必要があります。</p>
<p>複雑なイベントを処理する一つとして、libusbは、指定された時間後にタイムアウトする非同期転送をサポートします。</p>
<p>一部のプラットフォームではtimerfdが使用されるため、タイムアウト処理は単なる別のfdですが、他のプラットフォームでは、タイムアウト時またはタイムアウト後にlibusbを呼び出して処理する必要があります。
したがって、メイン・イベント・ループでlibusbのファイル・デスクリプターを考慮することに加えて、ファイル・デスクリプター・アクティビティがない場合でも、libusbを一定の時点で呼び出す必要がある場合があることも考慮する必要があります。詳細は
<a class="el" href="group__libusb__poll.html#polltime">時間ベースのイベントに関する注意</a>
を参照してください。</p>
<p>libusbを呼び出す必要がある時期を正確に知るために、libusbは、ポーリング可能なファイル・デスクリプターのセットと、次のタイムアウトがいつ期限切れになるかに関する情報を提供します。</p>
<p>非同期入出力APIを使用している場合は、以下の2つの選択肢のいずれかを選択する必要があります。そうしないと、入出力が完了しません。</p>
<h1><a class="anchor" id="pollsimple"></a> 単純な選択肢</h1>
<p>アプリケーションがlibusbのみを中心に展開し、他のイベント・ソースを処理する必要がない場合は、以下のようなプログラム構造にすることができます: </p><div class="fragment"><div class="line"><span class="comment">// initialize libusb</span></div>
<div class="line"><span class="comment">// find and open device</span></div>
<div class="line"><span class="comment">// maybe fire off some initial async I/O</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (user_has_not_requested_exit)</div>
<div class="line">    <a class="code"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events</a>(ctx);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 掃除(clean up)と終了(exit)</span></div>
</div><!-- fragment -->
<p>このような単純なメイン・ループを使用すると、ファイル・デスクリプターのセットの管理やタイムアウトの処理について心配する必要はありません。 <a
class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
は、これらの詳細を内部で処理します。</p>
<h1><a class="anchor" id="libusb_pollmain"></a> より高度な選択肢</h1>
<dl class="section note"><dt>注意</dt><dd>この機能は現在、Unixライクなプラットフォームでのみ利用できます。 Windowsでは、 <a class="el"
href="group__libusb__poll.html#ga54c27dcf8a95d2a3a03cfb7dd37eae63">libusb_get_pollfds()</a>
は単にNULLを返します。Windowsをサポートしたいアプリケーションは、代わりに <a class="el"
href="group__libusb__asyncio.html#eventthread">イベント処理スレッド</a>
を使用することをお勧めします。</dd></dl>
<p>より高度なアプリケーションでは、ネットワーク・ソケット、X11イベント、マウスの動きなど、他のイベント・ソースを監視するメイン・ループがすでに存在します。ファイル・デスクリプターのセットを公開することで、libusbはそのようなメイン・ループにきれいに統合されるように設計されています。</p>
<p>他のイベント・ソースのファイル・デスクリプターをポーリングすることに加えて、あなたはlibusbからファイル・デスクリプターのセットを取得し、それらも監視します。libusbのファイル・デスクリプターでアクティビティを検出すると、あなたは非ブロッキング・モードで
<a class="el"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout()</a>
を呼び出します。</p>
<p>さらに、libusbは特定の時点でイベントを処理する必要がある場合もあります。
これらの時点ではファイル・デスクリプター・アクティビティは生成されないため、アプリケーションはこれらの瞬間の次の1つが何時発生するかを(<a
class="el"
href="group__libusb__poll.html#ga5bc6f5bc71a43845244912da6679f634">libusb_get_next_timeout()</a>を呼び出すことにより)継続的に認識し、これらの瞬間が発生したときに非ブロッキング・モードで
<a class="el"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout()</a>
を呼び出す必要があります。 これは、それに応じて poll()/select() タイムアウトを調整する必要があることを意味します。</p>
<p>libusbは、ポーリングするファイル・デスクリプターのセットを提供し、それらすべてをポーリングして、それらを単一のエンティティとして扱うことを期待します。
セット内の各ファイル・デスクリプターの意味は、プラットフォームに依存する内部実装の詳細であり、リリースごとに異なる場合があります。
ファイル・デスクリプターの意味を解釈しようとしないでください。libusbが示すように、すべてを一度にポーリングしてください。</p>
<p>擬似コードで書くと、以下のようなものが必要です: </p><div class="fragment"><div class="line"><span class="comment">// libusbの利用準備をする(initialise)</span></div>
<div class="line"> </div>
<div class="line"><a class="code"
href="group__libusb__poll.html#ga54c27dcf8a95d2a3a03cfb7dd37eae63">libusb_get_pollfds</a>(ctx)</div>
<div class="line"><span class="keywordflow">while</span> (ユーザーがアプリケーションの終了を要求していない間) {</div>
<div class="line">    <a class="code"
href="group__libusb__poll.html#ga5bc6f5bc71a43845244912da6679f634">libusb_get_next_timeout</a>(ctx);</div>
<div class="line">    poll(libusbファイル・デスクリプターに加えて、関心のあるその他のイベント・ソースについて、</div>
<div class="line">        libusbが提案した値以下の <a class="code"
href="structlibusb__transfer.html#a9a12af15ca5b482f5dcaebd26a848cbb">タイムアウト</a>
を<span class="keyword">使用</span>)</div>
<div class="line">    <span class="keywordflow">if</span> (poll() がlibusbファイル・デスクリプターのアクティビティを示した)</div>
<div class="line">        <a class="code"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout</a>(ctx,
&amp;zero_tv);</div>
<div class="line">    <span class="keywordflow">if</span> (libusb <a class="code"
href="structlibusb__transfer.html#a9a12af15ca5b482f5dcaebd26a848cbb">タイムアウト</a>
ピッタリまたは過ぎている)</div>
<div class="line">        <a class="code"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout</a>(ctx,
&amp;zero_tv);</div>
<div class="line">    <span class="comment">// ここで他のソースからのイベントを処理します</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 掃除(clean up)と終了(exit)</span></div>
</div><!-- fragment -->
<h2><a class="anchor" id="polltime"></a> 時間ベースのイベントに関する注意</h2>
<p>時間を追跡し、特定の瞬間にlibusbを呼び出す必要があるという上記の複雑さは、いささか頭痛の種です。最大限の互換性を得るには、上記のようにメイン・ループを作成する必要がありますが、アプリケーションでサポートされているプラットフォームを制限すれば、より単純なスキームを使用することもできます。</p>
<p>これらの時間ベースのイベントの複雑化は、以下のプラットフォームでは<b>不要</b>です:</p><ul>
<li>Darwin</li>
<li>Linux。ただし、以下のバージョン要件が満たされている必要があります:<ul>
<li>Linux v2.6.27以降でtimerfdサポートでコンパイルされていること。</li>
<li>glibc v2.9 以上</li>
<li>libusb v1.0.5 以上</li>
</ul>
</li>
</ul>
<p>これらの構成では、 <a class="el"
href="group__libusb__poll.html#ga5bc6f5bc71a43845244912da6679f634">libusb_get_next_timeout()</a>
は常に0を返すため、メイン・ループは以下のように簡略化できます: </p><div class="fragment"><div class="line"><span class="comment">// libusbの利用準備をする(initialise)</span></div>
<div class="line"> </div>
<div class="line"><a class="code"
href="group__libusb__poll.html#ga54c27dcf8a95d2a3a03cfb7dd37eae63">libusb_get_pollfds</a>(ctx)</div>
<div class="line"><span class="keywordflow">while</span> (ユーザーがアプリケーションの終了を要求していない間) {</div>
<div class="line">    poll(libusbファイル・デスクリプターに加えて、関心のあるその他のイベント・ソースについて、</div>
<div class="line">        あなたの好きな任意の <a class="code"
href="structlibusb__transfer.html#a9a12af15ca5b482f5dcaebd26a848cbb">タイムアウト</a>
を <span class="keyword">使用</span>)</div>
<div class="line">    <span class="keywordflow">if</span> (poll() がlibusbファイル・デスクリプターのアクティビティを示した)</div>
<div class="line">        <a class="code"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout</a>(ctx,
&amp;zero_tv);</div>
<div class="line">    <span class="comment">// ここで他のソースからのイベントを処理します</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 掃除(clean up)と終了(exit)</span></div>
</div><!-- fragment -->
<p>メイン・ループを上記のように単純化すると、一部のプラットフォーム(レガシーなLinuxプラットフォームや、<em>時間ベースのイベント要件がある可能性のあるlibusbでサポートされる将来のプラットフォーム</em>を含む)との互換性が失われることに注意してください。結果として生じる問題は、アプリケーションの奇妙なバグとして表示される可能性があります。</p>
<p>あなたは <a class="el"
href="group__libusb__poll.html#gae7a654315636bebf404c1784429f06df">libusb_pollfds_handle_timeouts()</a>
関数を使用してランタイム・チェックを実行し、時間ベースのイベントの複雑さを無視しても安全かどうかを確認できます。アプリケーションがメイン・ループでlibusbの次のタイムアウトを無視するショートカットを使用している場合は、アプリケーションの起動時に
<a class="el"
href="group__libusb__poll.html#gae7a654315636bebf404c1784429f06df">libusb_pollfds_handle_timeouts()</a>
の戻り値を確認し、プラットフォームでこれらのタイミングの問題が発生した場合はアプリケーションの実行を中止(abort)することをお勧めします。</p>
<h2><a class="anchor" id="fdsetchange"></a> ファイル・デスクリプター・セットの変更</h2>
<p>libusbがイベント・ソースとして使用するファイル・デスクリプターのセットは、アプリケーションの存続期間中に変更される可能性があります。 <a
class="el"
href="group__libusb__poll.html#ga54c27dcf8a95d2a3a03cfb7dd37eae63">libusb_get_pollfds()</a>を繰り返し呼び出す必要はなく、
<a class="el"
href="group__libusb__poll.html#ga1b7b2deb193f2e9ffda5e727361d7e67">libusb_set_pollfd_notifiers()</a>
を使用して、ファイル・デスクリプター・セットが変更されたときの通知関数を設定できます。</p>
<h2><a class="anchor" id="mtissues"></a> マルチ・スレッドでの考慮事項</h2>
<p>残念なことに、複数のスレッドが機能するようになると、状況はさらに複雑になります。2つのスレッドが同じファイル・デスクリプターを監視している場合、イベントが発生したときに1つのスレッドのみがウェイクアップされるという事実は、いくつかの頭痛の種になります。</p>
<p>これらの問題を解決するために、イベント・ロックとイベント待ちロックと<a class="el"
href="group__libusb__poll.html#ga71da081f97afa3bf68aed8e372254e8f">libusb_handle_events_locked()</a>エンティティが追加されています。あなたは、それ以外の場合は、これらのエンティティを気にする必要はありません。</p>
<p>追加の文書も参照下さい: <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </p>
<h2 class="groupheader">Typedef解説</h2>
<a id="ga2962a11284b09a3f18936d8f73a43804"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga2962a11284b09a3f18936d8f73a43804">&#9670;&nbsp;</a></span>libusb_pollfd_added_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * libusb_pollfd_added_cb) (int fd, short events, void
*user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>イベントを監視するファイル・デスクリプターのセットに新しいファイル・デスクリプターを追加する必要がある場合に呼び出されるコールバック関数。 </p><dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>新しいファイル・デスクリプター </td></tr>
    <tr><td class="paramname">events</td><td>監視したいイベント。 <a class="el" href="structlibusb__pollfd.html">libusb_pollfd</a>
に説明があります。 </td></tr>
    <tr><td class="paramname">user_data</td><td><a class="el"
href="group__libusb__poll.html#ga1b7b2deb193f2e9ffda5e727361d7e67">libusb_set_pollfd_notifiers()</a>
の呼び出しで指定されたユーザー・データへのポインタ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>以下も参照して下さい</dt><dd><a class="el"
href="group__libusb__poll.html#ga1b7b2deb193f2e9ffda5e727361d7e67">libusb_set_pollfd_notifiers()</a> </dd></dl>

</div>
</div>
<a id="ga32aa803f54cfb5bfe8b41747e6b62af5"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga32aa803f54cfb5bfe8b41747e6b62af5">&#9670;&nbsp;</a></span>libusb_pollfd_removed_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * libusb_pollfd_removed_cb) (int fd, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>イベントを監視しているファイル・デスクリプターのセットからファイル・デスクリプターを一つ削除する必要がある場合に呼び出されるコールバック関数。
このコールバックから戻った後は、そのファイル・デスクリプターを再度使用しないでください。 </p><dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>監視を止めたいファイル・デスクリプター </td></tr>
    <tr><td class="paramname">user_data</td><td><a class="el"
href="group__libusb__poll.html#ga1b7b2deb193f2e9ffda5e727361d7e67">libusb_set_pollfd_notifiers()</a>
の呼び出しで指定されたユーザー・データへのポインタ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>以下も参照して下さい</dt><dd><a class="el"
href="group__libusb__poll.html#ga1b7b2deb193f2e9ffda5e727361d7e67">libusb_set_pollfd_notifiers()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">関数解説</h2>
<a id="ga6e5a116d5c9498ca4a0e29587fec1a05"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga6e5a116d5c9498ca4a0e29587fec1a05">&#9670;&nbsp;</a></span>libusb_try_lock_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_try_lock_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>イベント処理ロックの取得を試みます。このロックは、一度に1つのスレッドのみがlibusbイベント・ソースを監視していることを確認するために使用されます。</p>
<p>このロックを使用する必要があるのは、libusbのファイル・デスクリプターに対して poll() または select()
を直接呼び出すアプリケーションを開発している場合のみです。あなたがlibusbのイベント処理ループ関数(例: <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>)だけを使う場合は、このロックを気にする必要はありません。</p>
<p>このロックを保持している期間は実際にイベントを処理しているのだと信頼されます。イベントを処理しなくなった場合、あなたはできるだけ早く <a
class="el"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events()</a>
を呼び出さなければなりません。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならばロックが正常に取得された </dd>
<dd>
1ならばロックが取得されなかった場合(つまり、別のスレッドがロックを保持している場合) <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </dd></dl>

</div>
</div>
<a id="gaa72153938dc4f34decfacbc6cc6237ef"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gaa72153938dc4f34decfacbc6cc6237ef">&#9670;&nbsp;</a></span>libusb_lock_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_lock_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>イベント処理ロックを取得し、競合する場合は取得が成功するまでブロックします。このロックは、一度に1つのスレッドのみがlibusbイベント・ソースを監視していることを確認するために使用されます。</p>
<p>このロックを使用する必要があるのは、libusbのファイル・デスクリプターに対して poll() または select()
を直接呼び出すアプリケーションを開発している場合のみです。あなたがlibusbのイベント処理ループ関数(例: <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>)だけを使う場合は、このロックを気にする必要はありません。</p>
<p>このロックを保持している期間は実際にイベントを処理しているのだと信頼されます。イベントを処理しなくなった場合、あなたはできるだけ早く <a
class="el"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events()</a>
を呼び出さなければなりません。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacefbeabdd3409490dc4678f00779c165"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gacefbeabdd3409490dc4678f00779c165">&#9670;&nbsp;</a></span>libusb_unlock_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_unlock_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el"
href="group__libusb__poll.html#ga6e5a116d5c9498ca4a0e29587fec1a05">libusb_try_lock_events()</a>
または <a class="el"
href="group__libusb__poll.html#gaa72153938dc4f34decfacbc6cc6237ef">libusb_lock_events()</a>
で以前に取得したロックを解除します。このロックを解除すると、 <a class="el"
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event()</a>
でブロックされていたスレッドがすべてウェイクアップします。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63592b28c265185d9469d1e6920d8373"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga63592b28c265185d9469d1e6920d8373">&#9670;&nbsp;</a></span>libusb_event_handling_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_event_handling_ok </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>このスレッドがイベント処理を実行しても問題がないかどうかを判断します。</p>
<p>libusbがすべてのイベント・ハンドラーを一時的に停止する必要がある場合があります。これは、ファイル・デスクリプターをポーリングしてその場合が当てはまるかどうかを確認する前に使用する必要がある関数です。</p>
<p>この関数がスレッドにイベント・ロックを放棄するように指示する場合は、 <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a>
に記載されている通常のロジックを続行する必要があります。ループ次の反復では、スレッドはイベント・ロックの取得に失敗するため、イベント待ちになります。</p>
<p>この関数は、イベント・ロックが保持されている間に呼び出す必要があります。スレッドが現在のイベント・ハンドラーでない場合は、この関数の結果について心配する必要はありません。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>1ならばイベント処理を開始または続行できる </dd>
<dd>
0ならばこのスレッドがイベント・ロックを放棄する必要がある <a class="el"
href="libusb_mtasync.html#fullstory">マルチ・スレッド入出力: 全体の流れ</a> </dd></dl>

</div>
</div>
<a id="ga3a0a6e8be310c20f1ca68722149f9dbf"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga3a0a6e8be310c20f1ca68722149f9dbf">&#9670;&nbsp;</a></span>libusb_event_handler_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_event_handler_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>アクティブなスレッドがイベントを処理しているかどうか(つまり、誰がイベント処理ロックを保持しているかどうか)を判別します。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>1ならばスレッドがイベントを処理している場合 </dd>
<dd>
0ならば現在イベントを処理しているスレッドがない <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </dd></dl>

</div>
</div>
<a id="ga188b6c50944b49f122ccfd45b93fa9f2"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga188b6c50944b49f122ccfd45b93fa9f2">&#9670;&nbsp;</a></span>libusb_interrupt_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_interrupt_event_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>イベントを処理しているアクティブなスレッドに割り込み中断させます。これは主に、アプリケーションが <a class="el"
href="group__libusb__lib.html#gadc174de608932caeb2fc15d94fa0844d">libusb_exit()</a>
を呼び出したいときに、専用のイベント処理スレッドに割り込み中断させる場合に役立ちます。</p>
<p>バージョン 1.0.21 以降。 <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000105</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga150865a3f35c38173d688efa7ee52929"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga150865a3f35c38173d688efa7ee52929">&#9670;&nbsp;</a></span>libusb_lock_event_waiters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_lock_event_waiters </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>イベント待ちロックを取得します。
このロックは、イベントが完了したときに通知したい状況で取得するように設計されていますが、他のいくつかのスレッドはイベント処理中であるため、 <a
class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
の呼び出しは許可されていません。</p>
<p>あなたは、次に、このロックを取得し、別のスレッドがまだイベントを処理していることを再確認してから、 <a class="el"
href="group__libusb__poll.html#gae22755d523560be2867be7d09034ca50">libusb_wait_for_event()</a>
を呼び出します。</p>
<p>あなたがこのロックを使用する必要があるのは、libusbのファイル・デスクリプターで poll() または select()
を直接呼び出すアプリケーションを開発している場合していて、2つのスレッドからのイベントを同時に処理している可能性がある場合のみです。libusbのイベント処理ループ関数(例えば
<a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
など)のみを使っている場合は、このロックを気にする必要はありません。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41d7716458c11ee02d0deb19a31233ed"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga41d7716458c11ee02d0deb19a31233ed">&#9670;&nbsp;</a></span>libusb_unlock_event_waiters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_unlock_event_waiters </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>イベント待ちロックを解除します。 </p><dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae22755d523560be2867be7d09034ca50"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gae22755d523560be2867be7d09034ca50">&#9670;&nbsp;</a></span>libusb_wait_for_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_wait_for_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>別のスレッドがイベントの完了を通知するのを待ちます。イベント待ちロックを保持した状態で呼び出す必要があります。 <a class="el"
href="group__libusb__poll.html#ga150865a3f35c38173d688efa7ee52929">libusb_lock_event_waiters()</a>
を参照してください。</p>
<p>この関数は、以下の条件のいずれかが満たされるまでブロックされます:</p><ol type="1">
<li>タイムアウト期限切れ</li>
<li>転送完了</li>
<li>スレッドは、 <a class="el"
href="group__libusb__poll.html#gacefbeabdd3409490dc4678f00779c165">libusb_unlock_events()</a>
を介してイベント処理ロックを解放します。</li>
</ol>
<p>条件1は自明です。
条件2は、転送のコールバックが完了した<em>後に</em>スレッドをブロックしているのを解除します。条件3は、以前にイベントを処理していたスレッドがもはや処理をしなくなったことを意味するため重要です。したがってイベントが完了する場合は、別のスレッドが代わりにイベント処理を開始する必要があります。</p>
<p>この関数は、スレッドをスリープ状態にする前にイベント待ちロックを解放し、ウェイクアップ時にロックを再取得します。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
    <tr><td class="paramname">tv</td><td>このブロッキング関数の最大タイムアウト。 NULL値は無制限のタイムアウトを示します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば、転送が完了した後、または別のスレッドがイベント処理を停止した後は0 </dd>
<dd>
1ならばタイムアウトが期限切れ </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM timevalが無効な場合 <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </dd></dl>

</div>
</div>
<a id="ga43e52b912a760b41a0cf8a4a472fbd5b"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga43e52b912a760b41a0cf8a4a472fbd5b">&#9670;&nbsp;</a></span>libusb_handle_events_timeout_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_handle_events_timeout_completed </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>completed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>保留中のイベントを処理します。</p>
<p>libusbは、タイムアウトの期限が切れているかどうかを確認し、ファイル・デスクリプターのセットでアクティビティを確認することにより、
"保留中のイベント" を判別します。</p>
<p>timevalに0(ゼロ)が渡された場合、この関数は保留中のイベントを処理し、すぐに非ブロッキングスタイルで戻ります。</p>
<p>timevalが0以外で渡され、かつ、現在保留中のイベントがない場合、この関数は、指定されたタイムアウトまでイベントが処理されるのを待機しブロックします。イベントが到着したり、シグナルが発生したりすると、この関数はそれだけ早く戻ります。</p>
<p>completed
パラメーターがNULLでない場合、<em>イベント処理ロックを取得してから</em>、completedパラメーターの示すポインタで示された整数が0でない場合、この関数はすぐに戻ります。これにより、指定の転送の完了を競合無しで待機できます。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
    <tr><td class="paramname">tv</td><td>イベントの待機をブロックする最大時間、または非ブロック・モードの場合はすべてゼロのtimeval構造体 </td></tr>
    <tr><td class="paramname">completed</td><td>チェックする完了整数へのポインタ、またはNULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば成功 </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM timevalが不正な場合 </dd>
<dd>
LIBUSB_ERROR その他失敗 <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </dd></dl>

</div>
</div>
<a id="ga6deff4c7d3a6c04bb9ec9fd259b48933"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga6deff4c7d3a6c04bb9ec9fd259b48933">&#9670;&nbsp;</a></span>libusb_handle_events_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_handle_events_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>保留中のイベントを処理する</p>
<p><a class="el"
href="group__libusb__poll.html#ga43e52b912a760b41a0cf8a4a472fbd5b">libusb_handle_events_timeout_completed()</a>
と同様ですが、completedパラメーターがない場合、この関数を呼び出すことは、NULLのcompletedパラメーターを指定して <a
class="el"
href="group__libusb__poll.html#ga43e52b912a760b41a0cf8a4a472fbd5b">libusb_handle_events_timeout_completed()</a>
を呼び出すことと同じです。</p>
<p>この関数は、主に下位互換性のために保持されています。すべての新しいコードは、競合状態を回避するために <a class="el"
href="group__libusb__poll.html#ga0bc99f39e4cf5ad393cd5936c36037d1">libusb_handle_events_completed()</a>
または <a class="el"
href="group__libusb__poll.html#ga43e52b912a760b41a0cf8a4a472fbd5b">libusb_handle_events_timeout_completed()</a>
を呼び出す必要があります。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
    <tr><td class="paramname">tv</td><td>イベントの待機をブロックする最大時間、または非ブロック・モードの場合はすべてゼロのtimeval構造体 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば成功。LIBUSB_ERROR ならば失敗 </dd></dl>

</div>
</div>
<a id="ga4989086e3f0327f3886a4c474ec7c327"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga4989086e3f0327f3886a4c474ec7c327">&#9670;&nbsp;</a></span>libusb_handle_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_handle_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>保留中のイベントをブロック・モードで処理します。
現在、60秒にハード・コードされたタイムアウトがありますが、将来的には無制限にする予定です。この関数がブロッキングか非ブロッキングかをより細かく制御する場合、またはタイムアウトを制御する場合は、代わりに
<a class="el"
href="group__libusb__poll.html#ga43e52b912a760b41a0cf8a4a472fbd5b">libusb_handle_events_timeout_completed()</a>
を使用してください。</p>
<p>この関数は、主に下位互換性のために保持されています。すべての新しいコードは、競合状態を回避するために <a class="el"
href="group__libusb__poll.html#ga0bc99f39e4cf5ad393cd5936c36037d1">libusb_handle_events_completed()</a>
または <a class="el"
href="group__libusb__poll.html#ga43e52b912a760b41a0cf8a4a472fbd5b">libusb_handle_events_timeout_completed()</a>
を呼び出す必要があります。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば成功。LIBUSB_ERROR ならば失敗 </dd></dl>

</div>
</div>
<a id="ga0bc99f39e4cf5ad393cd5936c36037d1"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga0bc99f39e4cf5ad393cd5936c36037d1">&#9670;&nbsp;</a></span>libusb_handle_events_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_handle_events_completed </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>completed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>保留中のイベントをブロックモードで処理します。</p>
<p><a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
のように、completedパラメータを追加して、指定の転送の完了を競合無しで待機できるようにします。</p>
<p>completedパラメーターについては <a class="el"
href="group__libusb__poll.html#ga43e52b912a760b41a0cf8a4a472fbd5b">libusb_handle_events_timeout_completed()</a>
に詳しい説明があります。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
    <tr><td class="paramname">completed</td><td>チェックする完了整数へのポインタ、またはNULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば成功。LIBUSB_ERRORならば失敗。 <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </dd></dl>

</div>
</div>
<a id="ga71da081f97afa3bf68aed8e372254e8f"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga71da081f97afa3bf68aed8e372254e8f">&#9670;&nbsp;</a></span>libusb_handle_events_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_handle_events_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>他のスレッドがすでに処理しているかどうかを確認せずに、ファイル・デスクリプターをポーリングして保留中のイベントを処理します。
イベント・ロックを保持した状態で呼び出す必要があります。 <a class="el"
href="group__libusb__poll.html#gaa72153938dc4f34decfacbc6cc6237ef">libusb_lock_events()</a>
を参照してください。</p>
<p>この関数は、イベント・ロックを取得し、(<a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
または同様なのを使用するのではなく)libusbのファイル・デスクリプター子で直接 poll()/select()
を呼び出す状況で呼び出されるように設計されています。
libusbのデスクリプターでイベントを検出するため、(イベント・ロックを保持したまま)タイムアウト値をゼロにしてこの関数を呼び出します。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
    <tr><td class="paramname">tv</td><td>イベント待ちをブロックする最大時間、または非ブロック・モードの場合はゼロ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば成功 </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM timevalが不正な場合 </dd>
<dd>
LIBUSB_ERROR その他失敗 <a class="el"
href="libusb_mtasync.html">マルチ・スレッド・アプリケーションと非同期入出力</a> </dd></dl>

</div>
</div>
<a id="gae7a654315636bebf404c1784429f06df"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gae7a654315636bebf404c1784429f06df">&#9670;&nbsp;</a></span>libusb_pollfds_handle_timeouts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_pollfds_handle_timeouts </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>libusbのファイル・デスクリプターを監視するときに、アプリケーションが特別なタイミングの考慮事項を適用する必要があるかどうかを決定します。</p>
<p>この関数は、独自のメインループ(<a class="el"
href="group__libusb__poll.html#libusb_pollmain">より高度な選択肢</a>)でlibusbのファイル・デスクリプターを取得してポーリングするアプリケーションでのみ役立ちます。</p>
<p>通常、libusbのイベント・ハンドラーは、(ファイル・デスクリプター・セットにアクティビティがある場合に加えて)特定の時点で呼び出す必要があります。通常のアプローチは、
<a class="el"
href="group__libusb__poll.html#ga5bc6f5bc71a43845244912da6679f634">libusb_get_next_timeout()</a>
を使用して、次のタイムアウトがいつ発生するかを確認し、 poll()/select()
を調整することです。それに応じてタイムアウトし、その時点でライブラリを呼び出すことができるようにします。</p>
<p>libusbでサポートされている一部のプラットフォームには、この機能がありません。タイミングに関連するイベントは、ファイル・デスクリプター・セットのアクティビティによって表され、そして
<a class="el"
href="group__libusb__poll.html#ga5bc6f5bc71a43845244912da6679f634">libusb_get_next_timeout()</a>
は常に0を返します。この関数を使用すると、そのようなプラットフォームで実行しているかどうかを検出できます。</p>
<p>v1.0.5以降</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>0ならば <a class="el"
href="group__libusb__poll.html#ga5bc6f5bc71a43845244912da6679f634">libusb_get_next_timeout()</a>
によって決定された時間にlibusbを呼び出す必要がある。1ならばすべてのタイムアウト・イベントが内部またはファイル・デスクリプターの通常のアクティビティを通じて処理される。
<a class="el"
href="group__libusb__poll.html#libusb_pollmain">イベント処理のためのlibusbファイル・デスクリプターのポーリング</a> </dd></dl>

</div>
</div>
<a id="ga5bc6f5bc71a43845244912da6679f634"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga5bc6f5bc71a43845244912da6679f634">&#9670;&nbsp;</a></span>libusb_get_next_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libusb_get_next_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>libusbが処理する必要がある次の内部タイムアウトを決定します。この関数は、libusbのファイル・デスクリプターで poll() や
select() などを自分で呼び出す場合にのみ使用する必要があります。 <a class="el"
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events()</a>
またはその変種を直接呼び出す場合は、この関数を使用する必要はありません。</p>
<p>select() または poll() が結果を返すまで待機する時間を決定するには、あなたはメイン・ループでこの関数を呼び出す必要があります。
libusbはこのタイムアウトで呼び出される必要があるため、あなたは select() または poll()
呼び出しの上限として使用する必要があります。</p>
<p>タイムアウトの期限が切れたら、 <a class="el"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout()</a>
(おそらく非ブロッキング・モード)を呼び出して、libusbがタイムアウトを処理できるようにします。</p>
<p>この関数は、戻り値1(成功)、かつ、全てゼロのtimevalを返す場合があります。この場合は、libusbのタイムアウトがすでに期限切れになっていることを示しているため、すぐに
<a class="el"
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout()</a>
などを呼び出す必要があります。 戻り値0は、保留中のタイムアウトがないことを示します。</p>
<p>一部のプラットフォームでは、この関数は常に0(保留中のタイムアウト無し)を返します。 <a class="el"
href="group__libusb__poll.html#polltime">時間ベースのイベントに関する注意</a> を参照してください。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
    <tr><td class="paramname">tv</td><td>タイムアウト・イベントを処理するためにlibusbを呼び出す必要がある、現在の時刻(clock)に対する相対時間の出力場所 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>1ならばタイムアウトが返された。0ならば保留中のタイムアウトがない。LIBUSB_ERROR_OTHERならば失敗 </dd></dl>

</div>
</div>
<a id="ga1b7b2deb193f2e9ffda5e727361d7e67"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga1b7b2deb193f2e9ffda5e727361d7e67">&#9670;&nbsp;</a></span>libusb_set_pollfd_notifiers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_set_pollfd_notifiers </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__poll.html#ga2962a11284b09a3f18936d8f73a43804">libusb_pollfd_added_cb</a>&#160;</td>
          <td class="paramname"><em>added_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el"
href="group__libusb__poll.html#ga32aa803f54cfb5bfe8b41747e6b62af5">libusb_pollfd_removed_cb</a>&#160;</td>
          <td class="paramname"><em>removed_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ファイル・デスクリプターの追加/削除の通知機能を登録します。これらの関数は、libusbがイベント・ソースとして使用するすべての新規または削除されたファイル・デスクリプターに対して呼び出されます。</p>
<p>通知機能を削除するには、関数ポインタにNULL値を渡します。</p>
<p>注意: これらの通知機能を登録する前でも、ファイル・デスクリプターが追加されている可能性があることに注意してください(たとえば、<a
class="el"
href="group__libusb__lib.html#ga7deaef521cfb1a5b3f8d6c01be11a795">libusb_init()</a>
の時)</p>
<p>さらに、削除通知機能は a class="el"
href="group__libusb__lib.html#gadc174de608932caeb2fc15d94fa0844d">libusb_exit()</a>
中に呼び出される可能性があることに注意してください(たとえば、 <a class="el"
href="group__libusb__lib.html#ga7deaef521cfb1a5b3f8d6c01be11a795">libusb_init()</a>
時にオープンされてポーリング・セットに追加されたファイル・デスクリプターをクローズするとき)。 これが不要な場合は、 <a class="el"
href="group__libusb__lib.html#gadc174de608932caeb2fc15d94fa0844d">libusb_exit()</a>
を呼び出す直前に通知機能を削除してください。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
    <tr><td class="paramname">added_cb</td><td>追加通知用の関数へのポインタ </td></tr>
    <tr><td class="paramname">removed_cb</td><td>削除通知の関数へのポインタ </td></tr>
    <tr><td class="paramname">user_data</td><td>コールバックに返されるユーザー・データ(コンテキスト情報の受け渡しに役立ちます) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54c27dcf8a95d2a3a03cfb7dd37eae63"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#ga54c27dcf8a95d2a3a03cfb7dd37eae63">&#9670;&nbsp;</a></span>libusb_get_pollfds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el"
href="structlibusb__pollfd.html">libusb_pollfd</a>** libusb_get_pollfds </td>
          <td>(</td>
          <td class="paramtype"><a class="el"
href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>
*&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>libusbイベント・ソースとしてメイン・ループによってポーリングされる必要があるファイル・デスクリプターのリストを取得します。</p>
<p>返されるリストはNULLで終了するため、完了したら <a class="el"
href="group__libusb__poll.html#gad703b12ab275b6420c2c27e6279c955f">libusb_free_pollfds()</a>
で解放する必要があります。実際のリストの内容には触れないでください。</p>
<p>ファイル・デスクリプターはUnix固有の概念であるため、この関数はWindowsでは使用できず、常にNULLを返します。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>操作するコンテキスト、またはデフォルトのコンテキストの場合はNULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="structlibusb__pollfd.html">libusb_pollfd</a>
構造体のNULLで終了するリスト </dd>
<dd>
NULLの場合エラー </dd>
<dd>
NULLの場合機能が利用できないプラットフォーム </dd></dl>

</div>
</div>
<a id="gad703b12ab275b6420c2c27e6279c955f"></a>
<h2 class="memtitle"><span class="permalink"><a
href="#gad703b12ab275b6420c2c27e6279c955f">&#9670;&nbsp;</a></span>libusb_free_pollfds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libusb_free_pollfds </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el"
href="structlibusb__pollfd.html">libusb_pollfd</a> **&#160;</td>
          <td class="paramname"><em>pollfds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structlibusb__pollfd.html">libusb_pollfd</a>
構造体のリストを解放します。これは <a class="el"
href="group__libusb__poll.html#ga54c27dcf8a95d2a3a03cfb7dd37eae63">libusb_get_pollfds()</a>
で割り当てられたすべてのpollfdリストに対して呼び出す必要があります。</p>
<p>バージョン 1.0.20 以降。 <a class="el"
href="group__libusb__misc.html#gaabe4bc36a83358685d36a6c853cbb4de">LIBUSB_API_VERSION</a>
&gt;= 0x01000104</p>
<p>NULLのpollfdリストを使用してこの関数を呼び出すことは合法です。この場合、関数は単に何もしません。</p>
<dl class="params"><dt>パラメーター</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollfds</td><td>解放したい <a class="el" href="structlibusb__pollfd.html">libusb_pollfd</a>
構造体のリスト </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- contents -->
<div class="ttc" id="agroup__libusb__poll_html_ga4989086e3f0327f3886a4c474ec7c327"><div class="ttname"><a
href="group__libusb__poll.html#ga4989086e3f0327f3886a4c474ec7c327">libusb_handle_events</a></div><div class="ttdeci">int libusb_handle_events(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:2407</div></div>
<div class="ttc" id="astructlibusb__transfer_html_a9a12af15ca5b482f5dcaebd26a848cbb"><div class="ttname"><a
href="structlibusb__transfer.html#a9a12af15ca5b482f5dcaebd26a848cbb">libusb_transfer::timeout</a></div><div class="ttdeci">unsigned int timeout</div><div class="ttdoc">この転送のミリ秒単位のタイムアウト。</div><div class="ttdef"><b>定義:</b> libusb.h:1237</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga54c27dcf8a95d2a3a03cfb7dd37eae63"><div class="ttname"><a
href="group__libusb__poll.html#ga54c27dcf8a95d2a3a03cfb7dd37eae63">libusb_get_pollfds</a></div><div class="ttdeci">const struct libusb_pollfd ** libusb_get_pollfds(libusb_context *ctx)</div><div class="ttdef"><b>定義:</b> io.c:2719</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga5bc6f5bc71a43845244912da6679f634"><div class="ttname"><a
href="group__libusb__poll.html#ga5bc6f5bc71a43845244912da6679f634">libusb_get_next_timeout</a></div><div class="ttdeci">int libusb_get_next_timeout(libusb_context *ctx, struct timeval *tv)</div><div class="ttdef"><b>定義:</b> io.c:2539</div></div>
<div class="ttc" id="agroup__libusb__poll_html_ga6deff4c7d3a6c04bb9ec9fd259b48933"><div class="ttname"><a
href="group__libusb__poll.html#ga6deff4c7d3a6c04bb9ec9fd259b48933">libusb_handle_events_timeout</a></div><div class="ttdeci">int libusb_handle_events_timeout(libusb_context *ctx, struct timeval *tv)</div><div class="ttdef"><b>定義:</b> io.c:2387</div></div>

<!-- start footer part -->
<hr class="footer"/><address class="footer"><small> Generated on Fri Jul 9 2021 02:35:39 for libusb by &#160;<a
href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17 </small></address>
</body>
</html>
