<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libusb: Caveats</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libusb.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libusb
   &#160;<span id="projectnumber">1.0.24</span>
   </div>
   <div id="projectbrief">A cross-platform user library to access USB devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Caveats </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="threadsafety"></a>
Thread safety</h1>
<p>libusb is designed to be completely thread-safe, but as with any API it cannot prevent a user from sabotaging themselves, either intentionally or otherwise.</p>
<p>Observe the following general guidelines:</p>
<ul>
<li>Calls to functions that release a resource (e.g. <a class="el" href="group__libusb__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>, <a class="el" href="group__libusb__desc.html#ga18d2b08a065857ff7ae4f3f719c115cc">libusb_free_config_descriptor()</a>) should not be called concurrently on the same resource. This is no different than concurrently calling free() on the same allocated pointer.</li>
<li>Each individual <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> should be prepared by a single thread. In other words, no two threads should ever be concurrently filling out the fields of a <a class="el" href="structlibusb__transfer.html">libusb_transfer</a>. You can liken this to calling sprintf() with the same destination buffer from multiple threads. The results will likely not be what you want unless the input parameters are all the same, but its best to avoid this situation entirely.</li>
<li>Both the <a class="el" href="structlibusb__transfer.html">libusb_transfer</a> structure and its associated data buffer should not be accessed between the time the transfer is submitted and the time the completion callback is invoked. You can think of "ownership" of these things as being transferred to libusb while the transfer is active.</li>
<li>The various "setter" functions (e.g. <a class="el" href="group__libusb__lib.html#ga2efb66b8f16ffb0851f3907794c06e20">libusb_set_log_cb()</a>, <a class="el" href="group__libusb__poll.html#ga1b7b2deb193f2e9ffda5e727361d7e67">libusb_set_pollfd_notifiers()</a>) should not be called concurrently on the resource. Though doing so will not lead to any undefined behavior, it will likely produce results that the application does not expect.</li>
</ul>
<p>Rules for multiple threads and asynchronous I/O are detailed <a class="el" href="libusb_mtasync.html">here</a>.</p>
<h1><a class="anchor" id="fork"></a>
Fork considerations</h1>
<p>libusb is <em>not</em> designed to work across fork() calls. Depending on the platform, there may be resources in the parent process that are not available to the child (e.g. the hotplug monitor thread on Linux). In addition, since the parent and child will share libusb's internal file descriptors, using libusb in any way from the child could cause the parent process's <a class="el" href="group__libusb__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a> to get into an inconsistent state.</p>
<p>On Linux, libusb's file descriptors will be marked as CLOEXEC, which means that it is safe to fork() and exec() without worrying about the child process needing to clean up state or having access to these file descriptors. Other platforms may not be so forgiving, so consider yourself warned!</p>
<h1><a class="anchor" id="devresets"></a>
Device resets</h1>
<p>The <a class="el" href="group__libusb__dev.html#gafee9c4638f1713ca5faa867948878111">libusb_reset_device()</a> function allows you to reset a device. If your program has to call such a function, it should obviously be aware that the reset will cause device state to change (e.g. register values may be reset).</p>
<p>The problem is that any other program could reset the device your program is working with, at any time. libusb does not offer a mechanism to inform you when this has happened, so if someone else resets your device it will not be clear to your own program why the device state has changed.</p>
<p>Ultimately, this is a limitation of writing drivers in user space. Separation from the USB stack in the underlying kernel makes it difficult for the operating system to deliver such notifications to your program. The Linux kernel USB stack allows such reset notifications to be delivered to in-kernel USB drivers, but it is not clear how such notifications could be delivered to second-class drivers that live in user space.</p>
<h1><a class="anchor" id="blockonly"></a>
Blocking-only functionality</h1>
<p>The functionality listed below is only available through synchronous, blocking functions. There are no asynchronous/non-blocking alternatives, and no clear ways of implementing these.</p>
<ul>
<li>Configuration activation (<a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>)</li>
<li>Interface/alternate setting activation (<a class="el" href="group__libusb__dev.html#ga4858ad4f0f58fd1dc0afaead1fe6479a">libusb_set_interface_alt_setting()</a>)</li>
<li>Releasing of interfaces (<a class="el" href="group__libusb__dev.html#ga49b5cb0d894f6807cd1693ef29aecbfa">libusb_release_interface()</a>)</li>
<li>Clearing of halt/stall condition (<a class="el" href="group__libusb__dev.html#gab794bbc0b055d140f186f5a4d39c0891">libusb_clear_halt()</a>)</li>
<li>Device resets (<a class="el" href="group__libusb__dev.html#gafee9c4638f1713ca5faa867948878111">libusb_reset_device()</a>)</li>
</ul>
<h1><a class="anchor" id="configsel"></a>
Configuration selection and handling</h1>
<p>When libusb presents a device handle to an application, there is a chance that the corresponding device may be in unconfigured state. For devices with multiple configurations, there is also a chance that the configuration currently selected is not the one that the application wants to use.</p>
<p>The obvious solution is to add a call to <a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a> early on during your device initialization routines, but there are caveats to be aware of:</p><ol type="1">
<li>If the device is already in the desired configuration, calling <a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a> using the same configuration value will cause a lightweight device reset. This may not be desirable behaviour.</li>
<li>In the case where the desired configuration is already active, libusb may not even be able to perform a lightweight device reset. For example, take my USB keyboard with fingerprint reader: I'm interested in driving the fingerprint reader interface through libusb, but the kernel's USB-HID driver will almost always have claimed the keyboard interface. Because the kernel has claimed an interface, it is not even possible to perform the lightweight device reset, so <a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a> will fail. (Luckily the device in question only has a single configuration.)</li>
<li>libusb will be unable to set a configuration if other programs or drivers have claimed interfaces. In particular, this means that kernel drivers must be detached from all the interfaces before <a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a> may succeed.</li>
</ol>
<p>One solution to some of the above problems is to consider the currently active configuration. If the configuration we want is already active, then we don't have to select any configuration: </p><div class="fragment"><div class="line">cfg = -1;</div>
<div class="line"><a class="code" href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">libusb_get_configuration</a>(dev, &amp;cfg);</div>
<div class="line"><span class="keywordflow">if</span> (cfg != desired)</div>
<div class="line">    <a class="code" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration</a>(dev, desired);</div>
</div><!-- fragment --><p>This is probably suitable for most scenarios, but is inherently racy: another application or driver may change the selected configuration <em>after</em> the <a class="el" href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">libusb_get_configuration()</a> call.</p>
<p>Even in cases where <a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a> succeeds, consider that other applications or drivers may change configuration after your application calls <a class="el" href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration()</a>.</p>
<p>One possible way to lock your device into a specific configuration is as follows:</p><ol type="1">
<li>Set the desired configuration (or use the logic above to realise that it is already in the desired configuration)</li>
<li>Claim the interface that you wish to use</li>
<li>Check that the currently active configuration is the one that you want to use.</li>
</ol>
<p>The above method works because once an interface is claimed, no application or driver is able to select another configuration.</p>
<h1><a class="anchor" id="earlycomp"></a>
Early transfer completion</h1>
<p>NOTE: This section is currently Linux-centric. I am not sure if any of these considerations apply to Darwin or other platforms.</p>
<p>When a transfer completes early (i.e. when less data is received/sent in any one packet than the transfer buffer allows for) then libusb is designed to terminate the transfer immediately, not transferring or receiving any more data unless other transfers have been queued by the user.</p>
<p>On legacy platforms, libusb is unable to do this in all situations. After the incomplete packet occurs, "surplus" data may be transferred. For recent versions of libusb, this information is kept (the data length of the transfer is updated) and, for device-to-host transfers, any surplus data was added to the buffer. Still, this is not a nice solution because it loses the information about the end of the short packet, and the user probably wanted that surplus data to arrive in the next logical transfer.</p>
<h1><a class="anchor" id="zlp"></a>
Zero length packets</h1>
<ul>
<li>libusb is able to send a packet of zero length to an endpoint simply by submitting a transfer of zero length.</li>
<li>The <a class="el" href="group__libusb__asyncio.html#gga1fb47dd0f7c209b60a3609ff0c03d56da26b66334b6ec0537c49841ca623d901f">LIBUSB_TRANSFER_ADD_ZERO_PACKET</a> flag is currently only supported on Linux. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="agroup__libusb__dev_html_ga785ddea63a2b9bcb879a614ca4867bed"><div class="ttname"><a href="group__libusb__dev.html#ga785ddea63a2b9bcb879a614ca4867bed">libusb_set_configuration</a></div><div class="ttdeci">int libusb_set_configuration(libusb_device_handle *dev_handle, int configuration)</div><div class="ttdef"><b>Definition:</b> core.c:1630</div></div>
<div class="ttc" id="agroup__libusb__dev_html_gae921014b888b105471a31d54c77c1c4d"><div class="ttname"><a href="group__libusb__dev.html#gae921014b888b105471a31d54c77c1c4d">libusb_get_configuration</a></div><div class="ttdeci">int libusb_get_configuration(libusb_device_handle *dev_handle, int *config)</div><div class="ttdef"><b>Definition:</b> core.c:1544</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 10 2020 11:03:33 for libusb by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
